<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Linux进程控制块 - bobo&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="bobo&#039;s blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="bobo&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="这是操作系统老师布置的一项作业，作业内容如下：  试根据你自己的理解，采用类C语言设计和描述操作系统关于进程控制块的数据结构、组织方式及管理机制。在此基础上，给出进程的创建、终止、阻塞、唤醒、挂起与激活等函数原型及函数代码。注意，对于过于复杂的功能或你无法解决的细节可采用指定功能的函数模块如处理机scheduler()调度来替代。  这篇文章首先介绍了Linux操作系统中的进程控制块task_st"><meta property="og:type" content="blog"><meta property="og:title" content="Linux进程控制块"><meta property="og:url" content="https://panda-0129.github.io/ce94ceda/"><meta property="og:site_name" content="bobo&#039;s blog"><meta property="og:description" content="这是操作系统老师布置的一项作业，作业内容如下：  试根据你自己的理解，采用类C语言设计和描述操作系统关于进程控制块的数据结构、组织方式及管理机制。在此基础上，给出进程的创建、终止、阻塞、唤醒、挂起与激活等函数原型及函数代码。注意，对于过于复杂的功能或你无法解决的细节可采用指定功能的函数模块如处理机scheduler()调度来替代。  这篇文章首先介绍了Linux操作系统中的进程控制块task_st"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://panda-0129.github.io/img/og_image.png"><meta property="article:published_time" content="2018-04-06T13:26:12.000Z"><meta property="article:modified_time" content="2018-04-06T13:26:12.000Z"><meta property="article:author" content="金波"><meta property="article:tag" content="Linux"><meta property="article:tag" content="进程控制"><meta property="article:tag" content="操作系统"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://panda-0129.github.io/ce94ceda/"},"headline":"bobo's blog","image":["https://panda-0129.github.io/img/og_image.png"],"datePublished":"2018-04-06T13:26:12.000Z","dateModified":"2018-04-06T13:26:12.000Z","author":{"@type":"Person","name":"金波"},"description":"这是操作系统老师布置的一项作业，作业内容如下：  试根据你自己的理解，采用类C语言设计和描述操作系统关于进程控制块的数据结构、组织方式及管理机制。在此基础上，给出进程的创建、终止、阻塞、唤醒、挂起与激活等函数原型及函数代码。注意，对于过于复杂的功能或你无法解决的细节可采用指定功能的函数模块如处理机scheduler()调度来替代。  这篇文章首先介绍了Linux操作系统中的进程控制块task_st"}</script><link rel="canonical" href="https://panda-0129.github.io/ce94ceda/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="bobo's blog" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/panda.svg" alt="bobo&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/About">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Panda-0129"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-04-06T13:26:12.000Z" title="2018-04-06T13:26:12.000Z">2018-04-06</time>发表</span><span class="level-item"><time dateTime="2018-04-06T13:26:12.000Z" title="2018-04-06T13:26:12.000Z">2018-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a></span><span class="level-item">27 分钟读完 (大约4025个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Linux进程控制块</h1><div class="content"><p>这是操作系统老师布置的一项作业，作业内容如下：</p>
<blockquote>
<p>试根据你自己的理解，采用类C语言设计和描述操作系统关于进程控制块的数据结构、组织方式及管理机制。在此基础上，给出进程的创建、终止、阻塞、唤醒、挂起与激活等函数原型及函数代码。注意，对于过于复杂的功能或你无法解决的细节可采用指定功能的函数模块如处理机scheduler()调度来替代。</p>
</blockquote>
<p>这篇文章首先介绍了Linux操作系统中的进程控制块task_struct，再根据《操作系统原理》中的描述写了进程调度的伪代码。</p>
<a id="more"></a>

<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>​    Linux中的每个进程由一个task_struct数据结构来描述，这个结构体容纳了一个进程的所有信息，是系统对进程进行控制的唯一手段，也是最有效的手段。</p>
<p>​    我使用PD在电脑中安装了Linux虚拟机，内核版本为4.13.0-37，task_struct结构体定义在sched.h文件中，具体路径如下图：</p>


<p>​    Linux支持两种进程：普通进程和实时进程。实时进程具有一定程度上的紧迫性，要求对外部事件做出非常快的响应；而普通进程则没有这种限制。所以，调度程序要区分对待这两种进程，通常，实时进程比普通进程优先运行。</p>
<h4 id="task-struct成员"><a href="#task-struct成员" class="headerlink" title="task_struct成员"></a>task_struct成员</h4><ul>
<li><p>进程状态(state)</p>
<p>进程执行时，它会根据具体情况改变状态。进程状态是调度和对换的依据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br></pre></td></tr></table></figure>
<p>state的可能取值如下：</p>


<ul>
<li><p>五个互斥状态</p>
<p>state域能够取的这五个值互为排斥。</p>
</li>
</ul>
<figure><table><thead><tr><th style='text-align:left;' >状态</th><th style='text-align:left;' >描述</th></tr></thead><tbody><tr><td style='text-align:left;' >TASK_RUNNING</td><td style='text-align:left;' >可运行状态，要么正在运行、要么准备运行。正在运行的进程就是current指向的进程，准备运行的进程等待CPU片的调度。</td></tr><tr><td style='text-align:left;' >TASK_INTERRUPTIBLE</td><td style='text-align:left;' >可中断的等待状态，该状态的进程正在等待某个事件或某个资源，它位于系统中的某个等待队列中，可以被信号唤醒。</td></tr><tr><td style='text-align:left;' >TASK_UNINTERRUPTIBLE</td><td style='text-align:left;' >不可中断的等待状态，等待特定的系统资源，不可被打断，只能用特定的方式唤醒，例如唤醒函数wake_up()等。</td></tr><tr><td style='text-align:left;' >__TASK_STOPPED</td><td style='text-align:left;' >暂停状态，进程接收到SIGSTOP, SIGTTIN, SIGTSTP或者SIGTTOU信号后进入该状态。</td></tr><tr><td style='text-align:left;' >__TASK_TRACED</td><td style='text-align:left;' >表示进程被debugger等进程监视，进程执行被调试程序所停止。</td></tr></tbody></table></figure>

<ul>
<li><p>两个终止状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>	exit_state;</span><br><span class="line"><span class="keyword">int</span> exit_code;</span><br><span class="line"><span class="keyword">int</span> exit_signal;</span><br></pre></td></tr></table></figure>
<p>两个附加的进程状态既可以添加到state域中，又可以添加到exit_state域中。当进程终止时，会达到这两种状态。</p>
</li>
</ul>
<figure><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>EXIT_DEAD</td><td>进程的最终状态。</td></tr><tr><td>EXIT_ZOMBIE</td><td>进程的执行被终止，但是其父进程还未使用wait()等系统调用来获知它的终止信息，此时进程成为僵尸进程。</td></tr></tbody></table></figure>

<ul>
<li><p>睡眠状态</p>
<p>TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE都是睡眠状态。</p>
<p>内核提供了两种方法将进程置为睡眠状态：</p>
<ol>
<li><p>将进程设置为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE，并且调用schedule()函数。将进程从CPU运行队列中移除。</p>
</li>
<li><p>TASK_KILLABLE状态</p>
<figure><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>TASK_KILLABLE</td><td>当进程处于这种可终止的睡眠状态中时，可以响应致命信号</td></tr></tbody></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_WAKEKILL	128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of set_current_state: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_KILLABLE			(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED			(TASK_WAKEKILL | __TASK_STOPPED)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_TRACED			(TASK_WAKEKILL | __TASK_TRACED)</span></span><br></pre></td></tr></table></figure>
<p>即TASK_KILLABLE = TASK_WAKEKILL + TASK_UNINTERRUPTIBLE。</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-task-killable/index.html">https://www.ibm.com/developerworks/cn/linux/l-task-killable/index.html</a></p>
</blockquote>
</li>
<li><p>进程标识符(PID)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span>				pid;</span><br><span class="line"><span class="keyword">pid_t</span>				tgid;</span><br></pre></td></tr></table></figure>
<p>每个进程都有一个唯一的标识符，内核通过这个标识符来识别不同的进程，同时，进程标识符PID也是内核提供给用户程序的接口，用户程序通过PID对进程发号施令。PID是32位的无符号整数，顺序编号，新创建的进程通常是前一个进程的PID加1，Linux上允许的最大PID号为32767。</p>
<p>线程组所有线程与领头线程具有相同的PID，存入tgid字段，getpid()返回当前进程的tgid值。</p>
</li>
<li><p>进程内核栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *<span class="built_in">stack</span></span><br></pre></td></tr></table></figure>
<p>对每个进程，Linux内核把两个不同的数据结构紧凑的存放在一个单独为进程分配的内存区域中：</p>
<ol>
<li>内核态的进程堆栈</li>
<li>线程描述符thread_info</li>
</ol>
<p>Linux把这两个结构存放在一起，区域通常占8192K。</p>


<p>esp寄存器是CPU的栈指针，存放栈顶单元地址。</p>
</li>
<li><p>内核栈数据结构描述thread_info</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For reasons of header soup (see current_thread_info()), this</span></span><br><span class="line"><span class="comment">	 * must be the first element of task_struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">thread_info</span>	<span class="title">thread_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>thread_info结构定义在thread_info.h中：</p>

</li>
<li><p>进程标记</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per task flags (PF_*), defined further below: */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br></pre></td></tr></table></figure>
<p>反应进程状态的信息，但不是运行状态，用于内核识别进程当前的状态，以备下一步操作</p>
<p>flags成员的可能取值如下，这些宏以PF(ProcessFlag)开头。</p>

</li>
<li><p>表示进程亲属关系成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pointers to the (original) parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment"> * older sibling, respectively.  (p-&gt;father can be replaced with</span></span><br><span class="line"><span class="comment"> * p-&gt;real_parent-&gt;pid)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Real parent process: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>	*<span class="title">real_parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Recipient of SIGCHLD, wait4() reports: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>	*<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Children/sibling form the list of natural children:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">children</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">sibling</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">group_leader</span>;</span></span><br></pre></td></tr></table></figure>
<p>在Linux系统中，每个进程都有其父进程，也可能有零个或多个子进程。拥有同一父进程的所有进程具有兄弟关系。</p>
</li>
<li><p>进程调度</p>
<ul>
<li><p>优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>	prio;					<span class="comment">//保存动态优先级</span></span><br><span class="line"><span class="keyword">int</span>	static_prio;			<span class="comment">//保存静态优先级</span></span><br><span class="line"><span class="keyword">int</span> normal_prio;			<span class="comment">//取值取决于静态优先级和调度策略</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;	<span class="comment">//保存实时优先级</span></span><br></pre></td></tr></table></figure>
<p>实时优先级范围是0至MAX_RT_PRIO-1，普通进程的静态优先级范围是从MAX_RT_PRIO到MAX_PRIO-1。值越大静态优先级越低。</p>
<p>MAX_RT_PRIO定义在prio.h中：</p>



</li>
<li><p>调度策略相关字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>	<span class="title">se</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span>	</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br><span class="line"><span class="keyword">int</span>	nr_cpus_allowed;</span><br><span class="line"><span class="keyword">cpumask_t</span> cpus_allowed;</span><br></pre></td></tr></table></figure>
<figure><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>policy</td><td>调度策略</td></tr><tr><td>sched_class</td><td>调度类</td></tr><tr><td>se</td><td>普通进程的调用实体，每个进程都有其中之一的实体</td></tr><tr><td>rt</td><td>实时进程的调用实体，每个进程都有其中之一的实体</td></tr><tr><td>cpus_allowed</td><td>控制进程可以在哪里处理器上运行</td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>时间</p>
<p>一个进程从创建到终止叫做该进程的生存期（lifetime）。进程在其生存期内使用 CPU 的时间，内核都要进行记录，以便进行统计、计费等有关操作。进程耗费 CPU 的时间由两部 分组成：一是在用户模式（或称为用户态）下耗费的时间、一是在系统模式（或称为系统态） 下耗费的时间。每个时钟滴答，也就是每个时钟中断，内核都要更新当前进程耗费 CPU 的时 间信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">u64	utime;</span><br><span class="line">u64	stime;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_HAS_SCALED_CPUTIME</span></span><br><span class="line">	u64	utimescaled;</span><br><span class="line">	u64	stimescaled;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">u64	gtime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prev_cputime</span>	<span class="title">prev_cputime</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VIRT_CPU_ACCOUNTING_GEN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vtime</span> <span class="title">vtime</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Context switch counts: */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nvcsw;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nivcsw;</span><br><span class="line"><span class="comment">/* Monotonic time in nsecs: */</span></span><br><span class="line">u64	start_time;</span><br><span class="line"><span class="comment">/* Boot based time in nsecs: */</span></span><br><span class="line">u64	real_start_time;</span><br><span class="line"><span class="comment">/* MM fault and swap info: this can arguably be seen as either mm-specific or thread-specific: */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> maj_flt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_POSIX_TIMERS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_cputime</span>	<span class="title">cputime_expires</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cpu_timers</span>[3];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>	*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>	*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>	*<span class="title">cred</span>;</span></span><br><span class="line">                              </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">nameidata</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span>	<span class="title">sysvsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span>	<span class="title">sysvshm</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> last_switch_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>utime/stime</td><td>用于记录进程在用户态/内核态下所经过的节拍数</td></tr><tr><td>prev_utime/prev_stime</td><td>先前运行时间</td></tr><tr><td>utimescaled/stimescaled</td><td>记录进程在用户态/内核态的运行时间</td></tr><tr><td>gtime</td><td>用节拍计数的虚拟机运行时间</td></tr><tr><td>nvcsw/nivcsw</td><td>是自愿（voluntary）/非自愿（involuntary）上下文切换计数</td></tr><tr><td>last_switch_count</td><td>nvcsw和nivcsw总和</td></tr><tr><td>start_time/real_start_time</td><td>进程创建时间</td></tr><tr><td>cputime_expires</td><td>统计进程或进程组被跟踪的处理器时间</td></tr></tbody></table></figure>
</li>
<li><p>信号处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Signal handlers: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line"><span class="keyword">sigset_t</span> blocked;</span><br><span class="line"><span class="keyword">sigset_t</span> real_blocked;</span><br><span class="line"><span class="comment">/* Restored if set_restore_sigmask() was used: */</span></span><br><span class="line"><span class="keyword">sigset_t</span> saved_sigmask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>		<span class="title">pending</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;</span><br><span class="line"><span class="keyword">size_t</span> sas_ss_size;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sas_ss_flags;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>signal</td><td>指向进程的信号描述符</td></tr><tr><td>sighand</td><td>指向进程的信号处理程序描述符</td></tr><tr><td>blocked</td><td>表示被阻塞信号的掩码</td></tr><tr><td>pending</td><td>存放私有挂起信号</td></tr><tr><td>sas_ss_sp</td><td>信号处理程序备用堆栈地址</td></tr></tbody></table></figure>

<h4 id="进程组织方式"><a href="#进程组织方式" class="headerlink" title="进程组织方式"></a>进程组织方式</h4><ul>
<li><p>线性方式</p>
<p>把所有的task_struct组织在一张线性表中，将该表的首地址存放在内存的一个专用区域中，该方法实现简单、开销小，但每次查找需要扫描全表，适用于系统中进程数目不多的情况。</p>
</li>
<li><p>链接方式</p>
<p>把具有相同状态进程的task_struct分别通过task_struct中的链接字链接成一个队列。形成就绪队列、若干个阻塞队列和空白队列等。</p>

</li>
<li><p>索引方式</p>
<p>根据所有进程状态不同建立索引表，各个索引表在内存单元中的首地址也记录在内存中的专用单元中，用添加索引表的方式记录具有相应状态下的某个PCB在PCB表中的地址。</p>


</li>
</ul>
<h4 id="进程控制函数原型及代码创建、终止、阻塞、唤醒、挂起与激活"><a href="#进程控制函数原型及代码创建、终止、阻塞、唤醒、挂起与激活" class="headerlink" title="进程控制函数原型及代码创建、终止、阻塞、唤醒、挂起与激活"></a>进程控制函数原型及代码创建、终止、阻塞、唤醒、挂起与激活</h4>

<ul>
<li><p>进程创建</p>
<p>创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程。</p>
<p>在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语)：</p>
<ol>
<li>分配标识符，并申请空白进程控制块</li>
<li>为新进程的程序和数据及用户栈分配必要的内存空间</li>
<li>初始化进程控制块：自身/父进程标识符，处理机状态/调度信息</li>
<li>将新进程插入到就绪进程队列</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(struct task *task_struct, struct preparedQueue *q)</span> </span>&#123;</span><br><span class="line">    task_struct = (struct task *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct task)); <span class="comment">//分配内存空间</span></span><br><span class="line">    task_struct-&gt;pid = getpid();<span class="comment">//进程标识符</span></span><br><span class="line">    ………………						<span class="comment">//初始化进程控制块</span></span><br><span class="line">    insert(q, task_struct);		<span class="comment">//把当前控制块插入就绪进程队列</span></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进程终止</p>
<p>引起进程终止的事件主要有：正常结束，表示进程的任务已经完成和准备退出运行。异常结束，指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</p>
<p>操作系统终止进程的过程如下（撤销原语）：</p>
<ol>
<li>根据被终止进程的标识符，检索PCB，从中读出该进程的状态。</li>
<li>若被终止进程处于执行状态，立即终止该进程的执行，置调度标志为真，用于指示该进程被终止后应重新进行调度。</li>
<li>若该进程还有子进程，则应将其所有子进程终止。</li>
<li>将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。</li>
<li>将该PCB从所在队列（链表）中删除。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Terminate</span><span class="params">(pid, q, task_struct)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">//进程状态</span></span><br><span class="line">    <span class="keyword">bool</span> flag;	<span class="comment">//调度标志</span></span><br><span class="line">    <span class="comment">//处于运行状态，则终止进程执行，置调度标志为真。</span></span><br><span class="line">    <span class="keyword">if</span>(getState(pid) == running)&#123;</span><br><span class="line">        kill(pid);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//终止所有子进程</span></span><br><span class="line">    <span class="keyword">if</span>(isHaveSonNodes(pid)) &#123;</span><br><span class="line">        killAllSonNodes(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(task_struct);		<span class="comment">//归还资源</span></span><br><span class="line">    <span class="keyword">delete</span>(q, task_struct); <span class="comment">//从队列中删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进程阻塞</p>
<p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。</p>
<p>阻塞原语的执行过程是：</p>
<ol>
<li>找到将要被阻塞进程的标识号对应的PCB。</li>
<li>若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。</li>
<li>把该PCB插入到相应事件的等待队列中去。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Block</span><span class="params">(task_struct, pid, blockQueue q)</span> </span>&#123;</span><br><span class="line">    task_struct = getRunningTask(pid);		<span class="comment">//找到对应的PCB</span></span><br><span class="line">    stop(task_struct);				<span class="comment">//停止运行</span></span><br><span class="line">    task_struct-&gt;state = blocked;	<span class="comment">//转为阻塞状态</span></span><br><span class="line">    insert(q, task_struct);			<span class="comment">//插入等待队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进程唤醒</p>
<p>当被阻塞进程所期待的事件出现时，如它所启动的I/O操作已完成或其所期待的数据已到达，则由有关进程（比如，提供数据的进程）调用唤醒原语(Wakeup)，将等待该事件的进程唤醒。</p>
<p>唤醒原语的执行过程是：</p>
<ol>
<li>在该事件的等待队列中找到相应进程的PCB。</li>
<li>将其从等待队列中移出，并置其状态为就绪状态。</li>
<li>把该PCB插入就绪队列中，等待调度程序调度。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wakeUp</span> <span class="params">(pid, task_struct, blockedQueue p, preparedQueue q)</span> </span>&#123;</span><br><span class="line">    task_struct = getBlockedTask(pid);	<span class="comment">//找到对应的PCB</span></span><br><span class="line">    remove(p, task_struct);				<span class="comment">//从等待队列移出</span></span><br><span class="line">    tast_struct-&gt;state = ready;			<span class="comment">//状态改为就绪</span></span><br><span class="line">    insert(q, task_struct);				<span class="comment">//插入就绪队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进程挂起</p>
<ol>
<li>检查被挂进程现行状态并修改和插队</li>
<li>复制PCB到指定区域</li>
<li>若被挂进程正在执行则转向调度程序重新调度</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Suspend</span><span class="params">(pid, task_struct)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state = task_struct-&gt;state;</span><br><span class="line">    <span class="keyword">if</span>(task_struct-&gt;state = <span class="string">&quot;running&quot;</span>) &#123;</span><br><span class="line">        stop(task_struct);</span><br><span class="line">    &#125;</span><br><span class="line">    copy(task_struct);</span><br><span class="line">    <span class="keyword">switch</span>(state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;活动就绪&quot;</span>:</span><br><span class="line">            task_struct-&gt;state = <span class="string">&quot;静止就绪&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;活动阻塞&quot;</span>:</span><br><span class="line">            task_struct-&gt;state = <span class="string">&quot;静止阻塞&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(task_struct-&gt;state = <span class="string">&quot;running&quot;</span>) &#123;</span><br><span class="line">        scheduler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进程激活</p>
<ol>
<li>检查进程现行状态并修改和插队</li>
<li>若有新进程进入就绪队列且采用了抢占式调度策略，则检查和决定是否重新调度</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Active</span><span class="params">(pid, task_struct)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state = task_struct-&gt;state;</span><br><span class="line">    scheduler();	<span class="comment">//将挂起的进程从外存调入内存</span></span><br><span class="line">    <span class="keyword">switch</span>(state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;静止就绪&quot;</span>:</span><br><span class="line">            task_struct-&gt;state = <span class="string">&quot;活动就绪&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;静止阻塞&quot;</span>:</span><br><span class="line">            task_struct-&gt;state = <span class="string">&quot;活动阻塞&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(task_struct-&gt;state == <span class="string">&quot;ready&quot;</span>) &#123;</span><br><span class="line">        scheduler();	<span class="comment">//若有新进程进入就绪队列且采用了抢占式调度策略，则检查和决定是否重新调度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Linux/">Linux</a><a class="link-muted mr-2" rel="tag" href="/tags/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/">进程控制</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/d76fdac/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">编译原理-直接扫描法词法分析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/48c03696/"><span class="level-item">使用Graphviz绘图</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://cdn.jsdelivr.net/gh/Panda-0129/blogImage/5ca27779e017a6ec643c8bc941fb284.jpg" alt="bobo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">bobo</p><p class="is-size-6 is-block">Stay hungry, Stay Foolish.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京 · 中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">78</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">19</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Panda-0129" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Panda-0129"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/yuanzaizhichixy/"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/yuanzaizhich_xy"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="/boj01291127@gmail.com"><i class="far fa-envelope"></i></a></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=feedforall/bobo-Blog-0129&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="feedforall/bobo-Blog-0129" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div><p class="help">邮件订阅，更新早获取</p></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Array/"><span class="level-start"><span class="level-item">Array</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Backtracking/"><span class="level-start"><span class="level-item">Backtracking</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Breadth-first-Search/"><span class="level-start"><span class="level-item">Breadth-first Search</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Dynamic-Programing/"><span class="level-start"><span class="level-item">Dynamic Programing</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Dynamic-Programming/"><span class="level-start"><span class="level-item">Dynamic Programming</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/Graphviz%E7%BB%98%E5%9B%BE/"><span class="level-start"><span class="level-item">Graphviz绘图</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Hash-Table/"><span class="level-start"><span class="level-item">Hash Table</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Heap/"><span class="level-start"><span class="level-item">Heap</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">63</span></span></a></li><li><a class="level is-mobile" href="/categories/Linked-List/"><span class="level-start"><span class="level-item">Linked List</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Math/"><span class="level-start"><span class="level-item">Math</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/String/"><span class="level-start"><span class="level-item">String</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Two-Pointers/"><span class="level-start"><span class="level-item">Two Pointers</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/mac/"><span class="level-start"><span class="level-item">mac</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"><span class="level-start"><span class="level-item">搭建过程</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">日常学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">编译原理</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-15T07:59:30.000Z">2021-01-15</time></p><p class="title"><a href="/de20ad77/">LeetCode 刷题</a></p><p class="categories"><a href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2019-12-13T07:23:50.000Z">2019-12-13</time></p><p class="title"><a href="/9dbce41f/">Daily LeetCode 19. Remove Nth Node From End of List</a></p><p class="categories"><a href="/categories/LeetCode/">LeetCode</a> / <a href="/categories/Linked-List/">Linked List</a> / <a href="/categories/Two-Pointers/">Two Pointers</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2019-12-12T06:46:51.000Z">2019-12-12</time></p><p class="title"><a href="/ced9d002/">Daily LeetCode 17. Letter Combinations of a Phone Number</a></p><p class="categories"><a href="/categories/LeetCode/">LeetCode</a> / <a href="/categories/String/">String</a> / <a href="/categories/Backtracking/">Backtracking</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2019-12-11T06:33:47.000Z">2019-12-11</time></p><p class="title"><a href="/58cc1b58/">Daily LeetCode 15. 3Sum</a></p><p class="categories"><a href="/categories/LeetCode/">LeetCode</a> / <a href="/categories/Array/">Array</a> / <a href="/categories/Two-Pointers/">Two Pointers</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2019-12-10T13:57:30.000Z">2019-12-10</time></p><p class="title"><a href="/1e9553ba/">Daily LeetCode 11. Container With Most Water</a></p><p class="categories"><a href="/categories/LeetCode/">LeetCode</a> / <a href="/categories/Array/">Array</a> / <a href="/categories/Two-Pointers/">Two Pointers</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Graphivz/"><span class="tag">Graphivz</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag">26</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">26</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dot/"><span class="tag">dot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%98%E5%9B%BE/"><span class="tag">绘图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"><span class="tag">进程控制</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/panda.svg" alt="bobo&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 金波</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Panda-0129"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><form class="searchbox-input-container"><input class="searchbox-input" name="wd" type="text" placeholder="想要查找什么..."></form><a class="searchbox-close" href="javascript:;">×</a></div></div></div><script>(function ($) {
            $('.searchbox-input-container').on('submit', function (e) {
                var keyword = $('.searchbox-input[name="wd"]').val();
                window.location = 'https://www.baidu.com/s?wd=site:panda-0129.github.io ' + keyword;
                return false;
            });
        })(jQuery);
        (function (document, $) {
            $(document).on('click', '.navbar-main .search', function () {
                $('.searchbox').toggleClass('show');
            }).on('click', '.searchbox .searchbox-mask', function () {
                $('.searchbox').removeClass('show');
            }).on('click', '.searchbox-close', function () {
                $('.searchbox').removeClass('show');
            });
        })(document, jQuery);</script></body></html>