{"pages":[{"title":"About","text":"个人简介目前就读于北京交通大学，现阶段从事复述方向研究（开放域复述模板抽取），对NLP感兴趣，对博客内容有疑惑或有意见建议的，可以添加我的微信boj1127。 工作及教育经历 北京交通大学&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2019.9~至今 计算机与科学技术学院 &emsp; &emsp;&emsp; 计算机科学自然语言处理方向&emsp;&emsp;&thinsp;&thinsp;&thinsp;硕士在读 北京交通大学&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2015.9~2019.6 计算机与信息技术学院 &emsp;&emsp; &emsp;&thinsp;&thinsp;&thinsp;计算机科学与技术专业&emsp;&emsp;&emsp; &emsp; &emsp;本科","link":"/About/index.html"}],"posts":[{"title":"使用Github Pages + Hexo搭建博客（二）—— 写作","text":"在使用Github Pages + Hexo搭建博客（一）—— 配置git、Hexo中，我介绍了如何搭建一个基于Hexo的个人博客，以及将它部署到您的github pages上的方法。相信现在您已经搭建好了您的博客，下一步就是在自己的博客上发布文章了。因此，在这篇文章中，我将向您介绍在Hexo中写作以及发布文章的过程。 Hexo新建文章您可以使用以下命令来新建一篇文章： 1Hexo new [layout] &lt;title&gt; Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹中。 新建文章的布局若未指定，则默认为post。布局文件存放在根目录scaffolds文件夹下，可以自行修改。在新建完成后，您可以在您的source/_post文件夹中看到您新建的.md后缀文件，这就是您即将发布的文章。Hexo使用markdown语法书写文章，您可以先了解markdown语法，目前我使用的markdown编辑器是typroa，您也可以使用macdown。 注意事项： 文章标题有空格时需要用引号将标题括起来 小标题中#与内容之间要有空格，否则Hexo的渲染引擎无法识别小标题 Front-matter打开新建的文件，您就能看到定义在文件最上方的Front-matter部分，以---分割的区域中是用于指定当前文件的变量。 您的文件应当包含以下内容： 123456---title: #文章标题date: #创建时间tags: #文章标签---#这之后是正文 以下是预先定义的参数： 参数 描述 默认值 layout 布局 title 标题 文件名 date 建立日期 文件创建日期 updated 更新日期 文件更新日期 comments 是否开启文章的评论功能 true tags 标签 categories 分类 permalink 覆盖文章网址 设置文章的分类和标签Hexo中可以通过Front-matter中的tags和categories字段设置标签和分类。通常分类和标签定义很接近，但在Hexo中，分类具有顺序性和层次性。标签没有顺序和层次，可以通过[1，2，3，……]形式来给文章设置多个标签。 在之后的文章中，我将详细介绍在Next主题下设置文章分类和标签页面的方法。 标签插件与资源文件夹Hexo提供了一系列的标签插件来用于在文章中快速插入特定格式内容，官方文档中有详细的介绍。 资源文件夹可以方便我们对于各个文章资源的管理，可以将站点配置文件_config.yml中的post_asset_folder设置为true打开文章资源文件夹。 1post_asset_folder: true 资源文件管理功能打开后，每次在您新建新的文章时，Hexo都会自动创建一个与文章同名的资源管理文件夹，将与这篇文章有关的所有资源（图片、CSS、JS文件）放在此文件夹中，您就可以通过相对路径或者标签插件来引用它们。 注意： 当您想要在文章中引用资源文件夹中的图片时，如果您使用相对路径的常规markdown语法![]()，它将不会出现在首页，正确的引用方式应当是使用下列标签插件引用图片： 1{% asset_img example.jpg This is an example image %} 通过标签插件引用的方式，图片将会同时出现在文章、主页以及归档页中。 发布与删除文章在写完您的第一篇文章后，您可以先通过Hexo s命令在本地查看文章内容。完成修改后，就可以用以下命令生成新的静态文件并将文章push到您的github上。 123Hexo cleanHexo gHexo d 如果您想删除某一篇文章，那么在source/_post目录下找到对应的文章将其删除后，同样执行上述命令就行了。 结语看到此处，您应该已经成功在您的博客上发布了第一篇文章了，此时您一定想知道怎样才能让您的博客变得好看，在下一篇文章中，我将给您介绍如何在您的博客中使用、配置Next主题。","link":"/c438570b/"},{"title":"使用Github Pages + Hexo搭建博客（三）—— 配置Next主题","text":"在成功发布了第一篇文章后，我们来进行美化博客的工作。目前Hexo博客中使用最多的主题就是Next主题，在使用Next主题时，我们最好先查看官方的中文文档。我的文章也只是概括补充文档，并且介绍我个人配置过程中遇到的一些坑。 站点配置文件和主题配置文件在进行主题的配置之前，我们必须先了解站点配置文件和主题配置文件的区别，两个配置文件的文件名都为_config.yml。其中，站点配置文件是指根目录下的_config.yml文件，主要内容是Hexo自身的配置；另一份则位于主题目录下，称作主题配置文件，主要用于配置主题相关的选项。 使用Next主题 下载 在终端窗口定位到Hexo站点目录下，使用如下代码克隆最新版本： 1git clone https://github.com/iissnan/Hexo-theme-next themes/next 或者前往Next版本发布页面，下载zip文件到本地，解压至站点的themes目录下，并将解压后的文件夹名称改为next。 启用 打开站点配置文件，找到theme字段，将其值改为next。 1theme: next 主题设定 选择Scheme 在主题配置文件中搜索scheme关键字，就能够看到四行scheme的配置，将您需要启用的scheme前的注释#去掉即可。 12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 设置语言 在站点配置文件中，将language设置成网站使用的语言： 12#language: zh-Hans #简体中文#language: en #英语 设置站点信息 在站点配置文件的头部就能看到配置站点信息的键值对。 title是网站标题 subtitle是网站副标题，可以写一些个人喜欢的格言 description主要用于网站描述 author用来设置作者名 language用来设置网站使用的语言 timezone用来设置时区，默认使用您电脑的时区 设置菜单 菜单配置分为三个部分，分别是菜单项、显示文本以及对应图标。 菜单项 我们在前一篇文章中介绍了设置文章的分类以及标签。在Next主题中，我们可以在主题配置文件中修改menu字段中的内容，来设定菜单内容。菜单内容的设置格式是：item name: link。其中item name是一个名称，这个名称并不直接显示在页面上，它将用于匹配图标以及翻译。 菜单项的显示文本 Hexo在生成静态文件时使用第一步中设置的菜单名称查找对应语言的翻译，并提取显示文本，这些翻译保存在Next主题目录下的languages/{language}.yml中（{language} 为您所使用的语言）。 菜单项的图标 菜单项图标对应字段是menu_icons。此设定格式是item name: icon name，其中item name与上一步所配置的菜单名字对应，icon name是Font Awesome图标的名字。而enable可用于控制是否显示图标，您可以设置成false来去掉图标。 设置侧边栏 可以通过修改主题配置文件中的sidebar字段来设置侧边栏。 其中，通过设定siderbar.position为left或者right来实现侧边栏的靠左靠右放置。 通过设定sidebar.display的值为post、always、hide或是remove来实现侧边栏的默认显示、一直显示、在所有页面中隐藏（可手动展开）或是完全移除。 设置页面背景图片 在theme/next/source/css/_custom文件夹下打开custom.styl文件，添加如下代码： 123456789101112body { /* 将背景图片放到站点目录下source/uploads目录下*/ background: url(/uploads/background-cover.jpg) no-repeat; /* 背景图垂直、水平均居中 */ background-position: center center; /* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */ background-attachment: fixed; /* 让背景图基于容器大小伸缩 */ background-size: cover; /* 设置背景颜色，背景图加载过程中会显示背景色 */ background-color: rgba(0, 0, 0, 0.5);} 设置网站图标 官方文档中并没有说如何配置网站的图标，其实配置方式也很简单，在主题配置文件中有一个favicon字段，将您的图标放到themes/next/source/images目录下，将favicon字段值设置为您的图标文件名称，便可设置网站图标。 设置头像 修改主题配置文件中的avatar字段值来修改头像，头像文件可以放置在主题目录source/images目录下或者放置在站点目录source/uploads目录下（uploads不存在自行创建）。 设置阅读全文 可在每篇文章您想要分割的位置使用&lt;!--more--&gt;实现分割，我个人比较喜欢这种方式。 在主题配置文件中配置auto_excerpt字段 123auto_excerpt:enable: false #改写为truelength: 150 #默认显示高度 设置侧边栏社交链接 在主题配置文件中配置链接以及链接图标 social字段可配置链接，其键值格式为显示文本：链接地址 123456789101112social: GitHub: https://github.com/ E-Mail: xxx@xxx.com #Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/ 微博: https://weibo.com/ #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype social_icons字段可以设置社交链接的图标，其键值格式是匹配键: Font Awesome图标名称，匹配键与上一步所配置的链接的 显示文本相同（大小写严格匹配），图标名称是Font Awesome图标的名字（不必带fa-前缀）。 enable选项用于控制是否显示图标，您可以设置成false来去掉图标。 以上是官方文档中对于侧边栏社交链接图标设置方式的介绍，但是在实际设置过程中，我发现这是一个巨坑！！！！按照文档设置之后，图标并没有发生任何变化，依旧是默认的icon，在我百思不得其解时，我看到了social字段上的这样一句注释： 1234# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon(with or without delimeter) is not specified, globe icon will be loaded. 原来答案就在离我不远的地方，我们只需要在social字段中，在||前放链接，在其后放图标的Font Awesome名称即可改变图标。social_icon字段丢在一边就行了。 设置站点建立时间 站点建立时间将在站点底部显示，编辑主题配置文件，新增字段since即可。 结语这篇文章主要介绍了两个配置文件中的一些配置项，在下一篇文章中，我将介绍如何在Next主题中集成第三方服务，例如评论系统，站内搜索以及阅读统计等等。","link":"/39da2288/"},{"title":"使用Github Pages + Hexo搭建博客（一）—— 配置git、Hexo","text":"一直想要搭建一个博客，但一直没有付诸实施，抽了一个周末的时间捣鼓了一下github pages+Hexo的博客搭建方式，也算完成的一个并不完美的成品。本文基于官方文档，同时记录了我遇到的一些问题，下面就和大家分享我的搭建过程。 适用于mac环境的搭建 安装Git在mac上安装git有两种方式，最快的方式便是使用homebrew，具体方式可以参见brew文档。也可以直接从AppStore安装Xcode，在Xcode-&gt;Preferences中选择Downloads，选择Command Line Tools即可。 安装完成后，在终端输入git —version指令查看是否安装成功。 安装Node.js同样有两种方式安装Node.js。 第一种依旧是使用homebrew安装，使用如下命令安装： 12345brew link nodebrew uninstall nodebrew install node 第二种是通过安装包安装，在官网下载node的pkg安装包，并且额外安装npm即可。 安装完成后，在终端输入npm -v、node -v查看是否安装成功。 什么是Hexo官方文档这样介绍Hexo： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 在Jekyll和Hexo中，我最终选择了Hexo，当看到Hexo和Next的文档时，我便决定了使用Hexo，扁平化设计的网站和详细的文档有着无穷的吸引力。 安装Hexo必须在git和Node.js安装完成的情况下才能安装Hexo。 在完成上述安装后，只需使用简单地npm指令就能够完成安装 1npm install -g Hexo-cli 安装完成后，执行以下命令 12345Hexo init 'your folder name'cd 'your folder name'npm install 执行完毕后，您将在目录下看到这样的结构： 12345678.├── _config.yml├── package.json├── package-lock.json├── node_modules├── scaffolds├── source└── themes 在之后的文章中，我将介绍Hexo的文件结构等内容。 启动Hexo server执行下列命令 1Hexo s 正常情况下，启动过程完成后，使用浏览器访问http://127.0.0.1:4000 便能够看到一个Hello World博客页面。如果没有出现页面，可能是因为您电脑的4000端口被占用了，此时使用Hexo s -p port命令修改默认端口，再将4000修改为您设置的端口便能够进行访问。 创建属于自己的github pages第一步，我们需要创建一个属于自己的github帐号。Github官网链接 第二步，点击new repository创建一个新的仓库： 填写repository name时，格式必须为yourname.github.io，并且需要与您的用户名相同，否则会报404错误。 在创建完repository后，可以在库中先创建一个hello.html来，通过访问https://yourname.github.io 来检验您的github pages能否正常访问。 部署本地文件到Github首先要安装Hexo-deployer-git 1npm install Hexo-deployer-git —save 打开根目录下的站点配置文件_config.yml，在文件中添加如下内容，或者覆盖文件最后的deploy属性： 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 完成以上配置后，使用如下命令进行部署： 123Hexo cleanHexo gHexo d 也可以创建一个脚本文件commit.sh来简化操作。 结语如果没有发生错误，此时您便可以在浏览器中输入您的主页地址https://yourname.github.io查看到已经搭建完成的博客了，在后续的文章中，我将会介绍如何写作、如何使用Next主题（而不是默认的landscape）、配置站点文件以及集成第三方应用等方面的内容。","link":"/a6ceef8c/"},{"title":"使用Github Pages + Hexo搭建博客（四）—— 配置第三方服务","text":"静态站点拥有一定的局限性，因此，我们需要一些第三方服务来拓展站点功能。本文将介绍如何在Next主题下集成第三方服务。 评论系统Next支持多款评论系统，包括disqus、Facebook Coments、HyperComments、网易云跟帖等等，我个人使用的是disqus，其他工具的使用方法可以参考官方文档第三方服务集成部分。 配置disqus： 注册disqus 打开disqus官网，disqus支持Facebook、twitter以及Google帐号登录，也可以使用邮箱注册一个帐号。 配置disqus 登录后，点击GET STARTED，选择I want to install Disqus on my site ， Website Name就是配置文件中的short name，填写完成后即可点击Create Site，在接下来的页面中选择basic计划。之后就会跳转到选择站点平台界面，我们可以在页面最下方选择 再点击页面右下角的configure 此时的Website Name应当是您之前填写的内容，在Website URL中填写您的博客地址，点击完成设置，disqus官网部分的配置就完成了。 配置主题配置文件 编辑主题配置文件中的disqus部分，具体内容如下： 1234disqus: enable: false #设定为true shortname: #您设置的shortname count: true #是否显示评论数量 重新部署后您就能够在您的文章下看到评论界面啦，您也可以通过在Front-matter中设置comment为false关闭评论区。 阅读次数统计我是参考的为NexT主题添加文章阅读量统计功能实现文章阅读次数统计功能，统计功能由leancloud提供。 站内搜索Next主题支持集成Swiftype、微搜索、Local Search和Algolia。我使用的是Local Search，其他服务的配置过程同样可以在官方文档中查看。 配置Local Search： 安装Hexo-generator-searchdb，在站点根目录下执行下列命令： 1npm install Hexo-generator-searchdb --save 在站点配置文件中添加以下内容 12345search: path: search.xml field: post format: html limit: 10000 注意空格缩进 开启本地搜索 将主题配置文件中的local_search中enable设置为true开启本地搜索功能。 重新部署后就能够在侧边栏看到搜索按钮，站内搜索的配置就完成了。 我在配置过程过遇到了点击搜索后一直加载转圈的问题，通过开发者工具调试发现是search.xml文件的问题。将search.xml上传至https://www.xmlvalidation.com/分析发现如下错误： 将错误拿去谷歌搜索了一番，这个问题是因为md文件中产生了看不到的backspace字符，我们可以在vscode或者sublime text中打开md文件来筛查错误。 vscode需要在设置中打开renderControlCharacters 将类似图片中us字符的所有字符全部删除，重新部署后搜索功能就能够重新使用了。 文章字数统计与阅读时长 Next主题中以及集成了字数统计和阅读时长功能，我们需要先在根目录下使用下列命令安装Hexo-wordcount插件： 1npm install Hexo-wordcount --save 再到主题配置文件中开启wordcount统计功能： 12345678# Post wordcount display settings#Dependencies: https://github.com/willin/Hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 就能够打开文章的字数统计和阅读时长功能了。 在预览时，我们会发现，统计结果并没有单位，如果您想要加上单位，可以这样实现： 打开/themes/next/layout/_macro/post.swig文件 找到如下代码 123&lt;span title=&quot;{{ __('post.wordcount') }}&quot;&gt; {{ wordcount(post.content) }}&lt;/span&gt; 修改为 123&lt;span title=&quot;{{ __('post.wordcount') }}&quot;&gt; {{ wordcount(post.content) }} 字&lt;/span&gt; 再找到如下代码 123&lt;span title=&quot;{{ __('post.min2read') }}&quot;&gt; {{ min2read(post.content) }} &lt;/span&gt; 修改为 123&lt;span title=&quot;{{ __('post.min2read') }}&quot;&gt; {{ min2read(post.content) }} 分钟&lt;/span&gt; 重新部署就能够看到加上单位的统计信息了。 结语经过这些配置，您的博客现在已经可以正常使用了。但是，当您在搜索引擎中搜索您的博客时，会发现没有结果，这是由于您的站点没有做SEO优化，在下一篇文章中，我将介绍如何对您的站点进行SEO优化，从而能够在搜索引擎上找到您的博客。","link":"/bb8962d6/"},{"title":"使用Github Pages + hexo搭建博客（五）—— SEO优化","text":"当您完成了搭建工作，在谷歌搜索您的博客时，会发现搜索结果并不是如您所愿。这是因为您的博客还未进行SEO优化，本文将介绍博客SEO优化相关内容。 SEO的目标SEO即搜索引擎优化，通过SEO优化，我们能够使博客内容被搜索引擎收录并且提高优先排序，从而增加博客的点击率。 给博客添加站点地图Hexo集成了添加站点地图的插件，我们只需要在根目录下执行以下命令安装插件即可： 1npm install hexo-generator-sitemap --save 安装结束后，在主题配置文件中添加如下配置： 12sitemap: path: sitemap.xml 并且在站点配置文件修改url为您的博客的域名，默认值为http://yoursite.com ，如果不修改会导致后续站点地图测试错误。并且修改permalink。 123url: http://panda-0129.github.iopermalink: :title/ 添加robots.txtrobots.txt文件用于规定网站中不允许搜索引擎爬虫爬取的部分，从而规定部分的内容就不会被搜索引擎访问并收录。 在站点source文件夹下新建robots.txt文件，内容如下： 12345678910111213User-agent: *Allow: /Allow: /archives/Allow: /tags/Allow: /categories/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/ Allow部分可以根据你自己的menu配置。 添加nofollow标签这一项工作可以选择进行，可以参考这篇文章。 让Google收录你的站点完成上述准备工作后，先重新部署站点，再进行下面的步骤。 登录Google Search Console 添加你的博客域名： 测试robots.txt 如果你的robots.txt文件添加正常，此时你会在页面上看到你的文件内容，并且是0错误。此时根据提示提交即可。如果提示未找到robots.txt文件，你可以检查一下你的github库中站点根目录下是否有robots.txt文件。 测试并且提交站点地图 输入sitemap.xml，先测试再提交。如果报错，请检查站点配置文件中url是否配置正确。 设置抓取 这一步很重要！ 在这里我们填写需要抓取的url，在每一次添加文章后，我们可以将新文章的url填写至此进行抓取，抓取结果为完成、部分完成、重定向时均可请求提交索引。 结语完成上述步骤，就可以在Google搜索到你的个人博客了，你可以搜索测试一下。上述工作并不是完全的优化，我认为真正的优化还是在于优质的内容和频繁的更新，这才是优化的核心。 （ps：关于博客搭建的内容暂时告一段落了，深层次优化的内容等有空再写 - -）","link":"/7226cabb/"},{"title":"使用Graphviz绘图","text":"之前在电脑上绘图一直都是用visio或是各种在线的绘图网站，我个人觉得使用visio是一件很繁琐的事情。这学期有几节课需要绘图，我就又开始了对绘图方式的寻找。前几天偶然在网上发现了使用dot语言配合Graphviz绘图的方案，这种方案十分简洁明了。今天来介绍一下用Graphviz画图的方法。 dot语言dot语言是一门专为绘图设计的语言。 关键字 dot语言的关键字有node、edge、graph、digraph、subgraph和strict。 node：定义节点； edge：定义边；graph：定义无向图；digraph：定义有向图；subgraph：子图，继承父图属性：strict：防止相同两个节点之间重复连线 ID ID是我们自己定义的字符串，主要用于给图和节点命名。 命名规则 Any string of alphabetic ([a-zA-Z\\200-\\377]) characters, underscores ('_') or digits ([0-9]), not beginning with a digit; a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? ); any double-quoted string (“…”) possibly containing escaped quotes (&quot;)1; an HTML string (&lt;…&gt;). 不由数字开头的字符串；纯数字；双引号包裹的字符串，引号需要\\转义；尖括号包裹的HTML串。 使用 我们可以通过一个例子来了解ID的使用方式： 123graph yourID{ ……} 通常画简单图时图名可以省略。 结构声明 图 12345678graph { ……}//有向图digraph { ……} 节点 节点可以不经过声明直接使用。 也可以提前声明从而给节点定义属性，如下例: 1234digraph { a, b [color=blue] a-&gt;b;} 连线 有向图使用-&gt;连线，无向图使用--连线。 安装GraphvizGraphviz是由AT&amp;T实验室发布的基于DOT语言脚本的自动绘图软件。它使用dot作为脚本语言，再用布局引擎解析dot脚本，并且自动布局生成设定格式图片。 第一种安装方式是在官网下载安装包，但在mac环境下，我推荐使用brew方式安装，在终端输入brew install graphviz即可。 使用Graphviz绘制第一个图使用sublime text或者其他编辑器创建一个.dot后缀的文件，写入以下内容： 12345digraph { a-&gt;b; a-&gt;c; b-&gt;c;} 在命令行中执行dot -T png treeTest.dot -o treeTest.png，就能得到一个三条边的有向图treeTest.png如下： 命令行中 -T png是指定输出格式为png，也可以指定为svg、gif、pdf等格式。 节点属性 设置节点属性 全局设置 全局属性适用于一个图中的所有节点，用以下格式来全局设置节点属性： 12345graph { node [属性1=值1，属性2=值2 ...]; ......} 部分设置 当我们只想用设置图中一部分节点属性时，就应当使用局部属性设置： 12345678graph { //只设置node1节点 node1[属性1=值1，属性2=值2...] //同时设置node2和node3节点 node2, node3[属性1=值1，属性2=值2...] ......} 常用属性 我们可以通过一个例子来看一下节点的一些常用属性： 12345678910111213digraph node_intro { node [fontname=&quot;Microsoft Yahei&quot;]; shape1 [shape=box, label=&quot;蓝色边框矩形 &quot;, color=blue, fontsize=12]; shape2 [shape=circle, label=&quot;红色填充圆形 &quot;, style=filled, fillcolor=red]; shape3 [shape=doublecircle, label=&quot;双圈圆形&quot;, fontsize=24]; shape4 [shape=ellipse, label=&quot;红色字体椭圆 &quot;, fontcolor=red]; shape5 [shape=polygon, sides=4, skew=0.4, label=&quot;平行四边形 &quot;]; shape6 [shape=diamond, label=&quot;菱形 &quot;]; shape7 [shape=record, label=&quot;{记录1|记录2|记录3}&quot;]; shape8 [shape=none, label=&quot;无边框 &quot;]; shape1:s -&gt; shape2 -&gt; shape3 -&gt; shape4 -&gt; shape5 -&gt; shape6 -&gt; shape7 -&gt; shape8;} 绘制结果如下： 边属性同样用一个例子来了解边的常用属性： 12345678digraph edge_intro { style0, style1, style2, style3, style4 [label=&quot;&quot;]; style0 -&gt; style1 [style=solid, label=&quot;双向箭头蓝色实线 &quot;, dir=both, color=blue]; style1 -&gt; style2 [style=bold, label=&quot;方块粗线 &quot;, arrowhead=box]; style2 -&gt; style3 [style=dashed, label=&quot;短划线 &quot;]; style3 -&gt; style4 [style=dotted, label=&quot;虚线 &quot;];} 绘制结果如下： 更多的属性可以去看官方文档图形部分和箭头形状部分。 结语关于dot配合Graphviz绘图的内容就先介绍到这里啦。","link":"/48c03696/"},{"title":"编译原理-直接扫描法词法分析","text":"词法分析是编译过程的第一步工作，将字符流转换为单词序列，输出到中间文件中，这个中间文件将会作为语法分析程序的输入，进行下一步工作。 程序功能识别输入文件中的关键字、分隔符、标识符、数字、运算符、注释等。大小写不敏感，字母为az, A\\Z，数字为0~9。 什么是token 编译器从左向右扫描源文件，将其字符流分割成一个个的词，这里的词就是‘token’，即源文件中不可以再进一步分割的一串字符。 token类别：Token KeyToken ValueSpace空格Separator分隔符( ;，{，}，(，) )single-ch operator单字符运算符( =，+，-，*，/，%，;，|， :，!)two-ch operator双字符运算符(:=，!=，==)num数字less equal&lt;=NE&lt;&gt;less than&lt;greater equal&gt;=greater than&gt;reserved word保留字identifier标识符string字符串comment注释（单行、多行）error一些错误情况，例如数字开头的字符串other其他符号（换行、制表等） 输入输出 程序提供两种输入方式： 控制台输入 用于测试，输入以’#’结束的字符串。 文件输入 读取项目目录下的test.txt文件 运行结果输出也有两种方式 控制台 用于测试，输出_tokenArray结构体数组 文件输出 输出到result.xml文件中。 数据结构主要的数据结构如下： namefeaturereservedWord[]字符串数组，保存保留字str[]字符数组，保存从文件或控制台读取的字符token[]在每一遍扫描中暂存当前token，每一次扫描完成后重置_token键值对结构体，保存每个token的类型和内容_tokenArray_token结构体的结构体数组cursorOfStr记录当前扫描位置cursorOfStr记录当前结构体数组存放位置 123456789101112char* reservedWord [9] = {&quot;begin&quot;, &quot;end&quot;, &quot;if&quot;, &quot;then&quot;, &quot;else&quot;,&quot;for&quot;, &quot;do&quot;, &quot;while&quot;, &quot;and or not&quot;};char str [10240];char token [128];int cursorOfStr;int cursorOfToken;typedef struct _token { char str[128]; //存放token内容 char key[128]; //存放类型}_tokenStruct;struct _token _tokenArray[10240]; 程序结构 开发环境 系统：MacOs IDE：Xcode Version 9.3 编译：Apple LLVM 9.0 实现思路 分词方法有直接扫描和正则表达式匹配扫描法，本程序使用直接扫描法实现。 直接扫描字符进行筛选，通过每轮扫描，判断当前token属于哪种类型，扫描出当前完整的token，将其类型与对应的内容存放到结构体数组中。 例如： 在扫描一个小数时，一直向后扫描直到遇到第一个非数字且不是’ . ’的字符，然后将数字类型以及这个数字串存放到结构体数组中。 主要函数 main()函数 作为入口函数，调用了三个函数，分别是str_config()、getToken()以及out()。 str_config()函数 这个函数的工作是将待分析的内容保存到str数组中，提供了从文件读取或控制台输入两种方式。 c语言读取文件： 使用fopen()函数创建或打开一个新的文件 使用fgetc()函数读取字符 读取完成后，使用fclose()函数关闭文件 123456789 FILE *fp;cursorOfStr = 0;cursorOfToken = 0;fp = fopen(&quot;/Users/panda_0129/Documents/Learn/编译原理/lexicalAnalysis/lexicalAnalysis/test1.txt&quot;, &quot;r+&quot;);while ((ch=fgetc(fp)) != EOF) { str[i] = ch; i++;}fclose(fp); getToken()函数 这是实现扫描、获取token类型的函数，通过if条件判断实现。具体过程如下图所示： out()函数 顾名思义，out函数将分词完成得到的token结构体数组输出到文件或控制台。 输出文件为xml格式，具体格式如下： 123456&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;root&gt; &lt;Token&gt; &lt; &lt;/Token&gt;&lt;/root&gt; c语言写入文件： 使用fopen()函数创建或打开一个新文件，注意指定打开方式，允许写入 使用fputs()函数写入字符串 写入完成后，使用fclose()函数关闭文件 其他函数 1234567bool isASingle(char); //判断是否为单字符运算符int isReservedWord(char*); //判断是否为保留字int isInteger(char); //判断是否为数字int isChar(char); //判断是否为字母（a~z，A~Z）int isSeparator(char); //判断是否为分隔符int isSpace(char); //判断是否为空格char* toLower(char*); //将大写字母转换为小写，实现大小写不敏感 测试结果 使用test.txt文件测试，测试文件内容和输入文件内容分别如下： test.txt： 1234567891011//测试用例 &lt;= &gt;= == != &lt; &gt; +-3.1415926BEginx:=9;if x&gt;0then x:=2*x+1/3end result.xml： 见**result.xml**文件 实验总结实验最主要的部分就是扫描提取出token，在编写getToken()函数时，我遇到了一些bug。通过调试发现主要的问题都出现在了对于str数组下标取值的处理上，这也提醒了我自己在写代码时应该更加思路清晰，尽量减少不必要的错误。 用直接扫描法实现词法分析并不是一件很难的事情，但是使用直接扫描法的弊端在于很难对程序进行拓展，针对复杂一些的语言进行分析时，代码将会变得十分繁琐，不如基于正则匹配的词法分析。 这次实验加深了我对词法分析原理的理解，让我对课上学习到的一些原理有了更深刻的了解。同时也让我回忆了一些C语言的知识。 完整项目地址，求一个小星星(￣▽￣)”","link":"/d76fdac/"},{"title":"使用&#39;mtmr&#39;定制TouchBar","text":"在介绍这款定制软件之前我要先吐槽一下苹果新一代的蝶式键盘，这一代蝶式键盘频繁出现的连击问题真是让人无语，我已经出现了两次按键连击情况，换了两次c面组件了，只能但愿保修期到了之后不再连击了- - mtmr全称是’My TouchBar. My rules‘，是一款可以让你自定义Touch Bar的工具，说实话，用了快一年，我还是没有get到Touch Bar的作用，平常也就是局限于调调音量、亮度。这款软件的自由度还可以，虽说没有图形化界面，但是设置过程并不算复杂。 下载安装 下载最新的release 通过Homebrew安装brew cask install mtmr 设置 作者内置的按键类型 escape：esc按键 exitTouchbar：退出到默认Touchbar界面 brightnessUp：调高亮度 brightnessDown：调低亮度 volumeUp：调高音量 volumeDown：调低音量 mute：静音 dock：显示当前打开应用，可以实现应用间的快速切换 Native Plugins battery：显示当前电量 currency：一个适合币圈大佬的选项，可以显示当前比特币价格。 12345&quot;type&quot;: &quot;currency&quot;,&quot;refreshInterval&quot;: 600,&quot;align&quot;: &quot;right&quot;,&quot;from&quot;: &quot;BTC&quot;,&quot;to&quot;: &quot;USD&quot;, weather：显示当前天气情况 inputsource：显示输入法 Media Keys 内置播放器的支持项 previous：前一首 play：播放、暂停 next：后一首 AppleScript plugins sleep：睡眠 displaySleep：显示器休眠 图标 只支持base64编码的图片 我的设置123456789101112131415161718[ { &quot;type&quot;: &quot;escape&quot;, &quot;width&quot;:64, &quot;align&quot;: &quot;left&quot; }, { &quot;type&quot;: &quot;exitTouchbar&quot;, &quot;width&quot;: 44, &quot;align&quot;: &quot;left&quot; }, { &quot;type&quot;: &quot;brightness&quot;, &quot;width&quot;: 80, &quot;align&quot;: &quot;left&quot;, &quot;image&quot;: { &quot;base64&quot;:…… } }, { &quot;type&quot;: &quot;weather&quot;, &quot;icon_type&quot;: &quot;images&quot;, &quot;units&quot;: &quot;metric&quot;, &quot;align&quot;: &quot;left&quot;}, { &quot;type&quot;: &quot;dock&quot;, &quot;width&quot;: 300, &quot;align&quot;: &quot;left&quot; }, { &quot;type&quot;: &quot;mute&quot;, &quot;width&quot;: 40, &quot;align&quot;: &quot;right&quot; }, { &quot;type&quot;: &quot;battery&quot;, &quot;align&quot;: &quot;right&quot; }, { &quot;type&quot;: &quot;timeButton&quot;, &quot;align&quot;: &quot;right&quot; }]","link":"/916c46e9/"},{"title":"编译原理——OPG","text":"这个实验花了我半天的时间完成，不算是很复杂。算符优先分析属于移进归约分析法的一种，算是最易实现的移进归约分析方法。 程序功能 设计目标 给定算符优先文法及输入串，自动构造算符优先关系表并且输出分析过程。 开发环境 系统：macOS High Sierra IDE: IntelliJ IDEA 语言：Java 输入输出 输入分两部分： 文法 文法通过文件读取，⽂件结构：第⼀⾏为使⽤逗号分隔的⾮终结符，第⼆⾏为使⽤逗号分隔的终结符，其后是各个产⽣式。 输入串 以#结尾，通过键盘输入 输出包括当前文法的FIRSTVT集、LASTVT集、优先关系表、分析过程。 算符优先分析算符优先分析的核心思想就是通过定义终结符之间的优先关系，根据这些优先关系，进行句柄的选取。终结符之间定义三种优先关系：&lt;、=和&gt;，我们可以通过FIRSTVT集和LASTVT集来构造算符优先关系。 FIRSTVT集和LASTVT集 U∈Vn ①FIRSTVT(U)={b|U=^+^&gt;b…, 或U=^+^&gt;Vb…, b∈Vt, V∈Vn} 则形如W-&gt;…aU…的规则 a&lt;b b∈FIRSTVT(U) ②LASTVT(U)={a|U=^+^&gt;…a, 或U=^+^&gt;…aV, a∈Vt, V∈Vn 则形如W→…Ub…的规则 a&gt;b a∈LASTVT(U) 构造FIRSTVT(U)和LASTVT(U)的算法 找Firstvt的三条规则： 如果要找A的Firstvt，A的候选式中出现： A-&gt;a…….，即以终结符开头，该终结符入Firstvt A-&gt;B…….，即以非终结符开头，该非终结符的Firstvt入A的Firstvt A-&gt;Ba…..，即先以非终结符开头，紧跟终结符，则终结符入Firstvt 结合代码以及注释来看一下具体的实现过程： 1234567891011121314151617181920212223242526272829303132333435363738class FirstVT { Set getFirstVt(String str) { Set set = new Set(str);// 已经求过的VN ArrayList&lt;String&gt; First = new ArrayList&lt;&gt;(); First.add(str); for (Production production : Config.productions) { if (production.head.equals(str)) { for (String body : production.body) { for (String vt : Config.VT) {// 通过当前产生式中终结符的位置来判断该产生式属于算法中的哪种类型 if (body.contains(vt)) { int index = body.indexOf(vt);// A-&gt;a...和A-&gt;Ba...两种情况，直接加入集合 if (index == 0 || index == 1) { set.addSet(vt); } } } for (String vn : Config.VN) { if (body.contains(vn)) { int index = body.indexOf(vn);// A-&gt;B...这种情况时，若当前FITSTVT(vn)未被加入当前FIRSTVT集，则加入 if (index == 0 &amp;&amp; !First.contains(vn)) { set.addSet(getFirstVt(vn)); } } } } } } return set; }} 找Lastvt的三条规则： 如果要找A的Lastvt，A的候选式中出现： A-&gt;…….a，即以终结符结尾，该终结符入Lastvt A-&gt;…….B，即以非终结符结尾，该非终结符的Lastvt入A的Lastvt A-&gt;…..aB，即先以非终结符结尾，前面是终结符，则终结符入Lastvt 结合代码注释看一下该算法的具体实现过程： 123456789101112131415161718192021222324252627282930313233class LastVT { Set getLastVt(String str) { Set set = new Set(str); ArrayList&lt;String&gt; Last = new ArrayList&lt;&gt;(); Last.add(str); for (Production production : Config.productions) { if (production.head.equals(str)) { for (String body : production.body) {// A-&gt;...a，即以终结符结尾，该终结符入Lastvt if (Config.VT.contains(String.valueOf(body.charAt(body.length() - 1)))) { set.addSet(String.valueOf(body.charAt(body.length() - 1))); }// A-&gt;...B，即以非终结符结尾，该非终结符的Lastvt入A的Lastvt if (Config.VN.contains(String.valueOf(body.charAt(body.length() - 1))) &amp;&amp; !Last.contains(String.valueOf(body.charAt(body.length() - 1)))) { set.addSet(getLastVt(String.valueOf(body.charAt(body.length() - 1)))); }// A-&gt;...aB，即先以非终结符结尾，前面是终结符，则终结符入Lastvt if (body.length() &gt; 1 &amp;&amp; Config.VN.contains(String.valueOf(body.charAt(body.length() - 1))) &amp;&amp; Config.VT.contains(String.valueOf(body.charAt(body.length() - 2)))) { set.addSet(String.valueOf(body.charAt(body.length() - 2))); } } } } return set; }} 根据FIRSTVT集和LASTVT集构造算符优先关系表 构造算法： FOR 每条规则 U-&gt;X1X2…Xn DO ​ FOR i=1 TO n-1 DO ​ BEGIN ​ IF Xi和Xi+1均为终结符，THEN 置 Xi=Xi+1 ​ IF i≤n-2，且Xi和Xi+2都为终结符号 但Xi+1为非终结符号 ​ THEN 置 Xi=Xi+2 ​ IF Xi为终结符号Xi+1为非终结符号 THEN ​ FOR FIRSTVT(Xi+1)中的每个b DO ​ 置Xi&lt;b ​ IF Xi为非终结符号Xi+1为终结符号 THEN ​ FOR LASTVT(Xi)中的每个a DO ​ 置a&gt;Xi+1 ​ END 具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void generateTable() {// 初始化当前表 for (int i = 0; i &lt; Config.VT.size() + 2; i++) { for (int j = 0 ; j &lt; Config.VT.size() + 2; j++) { table[i][j] = &quot;&quot;; } }// 设置表的第一列与第一行 table[0][Config.VT.size() + 1] = &quot;#&quot;; table[Config.VT.size() + 1][0] = &quot;#&quot;; for (int i = 1; i &lt; Config.VT.size() + 1; i++) { table[0][i] = Config.VT.get(i - 1); table[i][0] = Config.VT.get(i - 1); } for (Production production : Config.productions) { for (String body : production.body) { for (int i = 0; i &lt; body.length() - 1; i++) {// 产生式中有终结符相邻情况，则Xi=Xi+1 if (Config.VT.contains(String.valueOf(body.charAt(i))) &amp;&amp; Config.VT.contains(String.valueOf(body.charAt(i + 1)))) { ArrayList&lt;Integer&gt; tmpPos = getPos(String.valueOf(body.charAt(i)), String.valueOf(body.charAt(i + 1))); table[tmpPos.get(0)][tmpPos.get(1)] = &quot;=&quot;; }// 产生式中有终结符非终结符终结符情况，则Xi=Xi+2 if (i &lt;= body.length() - 3 &amp;&amp; Config.VT.contains(String.valueOf(body.charAt(i))) &amp;&amp; Config.VT.contains(String.valueOf(body.charAt(i + 2))) &amp;&amp; Config.VN.contains(String.valueOf(body.charAt(i + 1)))) { ArrayList&lt;Integer&gt; tmpPos = getPos(String.valueOf( body.charAt(i)), String.valueOf(body.charAt(i + 2))); if (tmpPos.size() == 2) { table[tmpPos.get(0)][tmpPos.get(1)] = &quot;=&quot;; } }// 产生式中存在终结符后紧接着非终结符的情况 if (Config.VT.contains(String.valueOf(body.charAt(i))) &amp;&amp; Config.VN.contains(String.valueOf(body.charAt(i + 1)))) {// 当前非终结符的FIRSTVT集中的每个b，都置当前终结符&lt;b for (String b : firstVT.getFirstVt(String.valueOf(body.charAt(i + 1))).body) { ArrayList&lt;Integer&gt; tmpPos = getPos(String.valueOf(body.charAt(i)), b); table[tmpPos.get(0)][tmpPos.get(1)] = &quot;&lt;&quot;; } }// 产生式中存在非终结符后紧接着终结符的情况 if (Config.VN.contains(String.valueOf(body.charAt(i))) &amp;&amp; Config.VT.contains(String.valueOf(body.charAt(i + 1)))) {// 当前非终结符符号LASTVT集中的每个a，置当前a&gt;当前终结符 for (String a : lastVT.getLastVt(String.valueOf(body.charAt(i))).body) { ArrayList&lt;Integer&gt; tmpPos = getPos(a, String.valueOf(body.charAt(i + 1))); table[tmpPos.get(0)][tmpPos.get(1)] = &quot;&gt;&quot;; } } } } }// 对#的处理// #&lt;FIRSTVT(起始符号) for (int i = 0; i &lt; firstVT.getFirstVt(Config.productions.get(0).head).body.size(); i++) { for (String a : firstVT.getFirstVt(Config.productions.get(0).head).body) { int tmp = getPosX(a); if (tmp &gt;= 0) table[Config.VT.size() + 1][tmp] = &quot;&lt;&quot;; } }// #&gt;LASTVT(起始符号) for (int i = 0; i &lt; lastVT.getLastVt(Config.productions.get(0).head).body.size(); i++) { for (String a : lastVT.getLastVt(Config.productions.get(0).head).body) { int tmp = getPosY(a); if (tmp &gt;= 0) table[tmp][Config.VT.size() + 1] = &quot;&gt;&quot;; } }} 算符优先分析过程 算符优先分析算法： while(true) ​ if #在栈顶且输入串下标指向# 则 ​ return success; ​ else ​ 令a是栈最上面的终结符，b是当前输入串下标对应符号 ​ if a&lt;b 或 a=b ​ b入栈 ​ 下标指向下一个输入符号 ​ else if a&gt;b ​ do ​ 出栈 ​ while 栈顶终结符与&lt;最近弹出的终结符 ​ else error() 具体实现： 12345678910111213141516171819202122232425262728293031323334void analyze () {// 初始化符号栈、获取输入串 init();// 记录最近出栈符号 String recentPop; while (true) {// #在栈顶，且输入串下标指向# if (analyzeStack.peek().equals(&quot;#&quot;) &amp;&amp; inputStack.get(cursorOfInput).equals(&quot;#&quot;)) { System.out.println(&quot;Success&quot;); return; } else {// a&lt;b 或 a=b if (isLess(analyzeStack.peek(), inputStack.get(cursorOfInput)) || isEqual(analyzeStack.peek(), inputStack.get(cursorOfInput))) { analyzeStack.push(inputStack.get(cursorOfInput)); cursorOfInput++; outputStack(); }// a&gt;b else if (isLarger(analyzeStack.peek(), inputStack.get(cursorOfInput))) { recentPop = analyzeStack.peek(); while ( !isLess(analyzeStack.peek(), recentPop) ) { recentPop = analyzeStack.pop(); } outputStack(); } else { System.out.println(&quot;Error&quot;); return; } } } } 测试 测试用例 12345E,T,F+,-,*,/,i,(,)E-&gt;E+T|E-T|TT-&gt;T*F|T/F|FF-&gt;(E)|i 运行结果 项目地址：https://github.com/Panda-0129/OPG","link":"/d0de14ce/"},{"title":"Daily LeetCode 205. Isomorphic Strings","text":"https://leetcode.com/problems/isomorphic-strings/ Easy 问题描述：Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: 12Input: s = &quot;egg&quot;, t = &quot;add&quot;Output: true Example 2: 12Input: s = &quot;foo&quot;, t = &quot;bar&quot;Output: false Example 3: 12Input: s = &quot;paper&quot;, t = &quot;title&quot;Output: true Note:You may assume both s and t have the same length. 题目分析：给定字符串s和t，我们需要判断两个字符串的结构是否相同，即它们是不是同构的。 我看到这一题最初的思路是分别处理s和t，将字符串转换为数字的形式，拿例1来说，将s转换成011，t也转换成011，两个数字相等，那么两个字符串就是同构的，但这种解决方法会导致超时。 另一个解题思路就是从一个字符串入手，找该字符串和另一个字符串之间的联系。我们可以建立一个字典，来建立从字符串s到字符串t的映射。 拿例3来说，我们设置一个字典dict_tmp，遍历s，如果当前ith字符ch不在字典中，我们先查看是否存在s-&gt;t的映射，若已经存在，那么说明不是同构，因为我们要确保映射的一一对应；若不存在，我们就将dict_tmp[ch]设置为t[i]。 如果当前字符在字典中，则说明该字符在之前的遍历过程中已经出现过，这时我们需要判断t中对应位置上的字符是否与上次记录的字符相同，即dict_tmp[ch]是否等于t[i]，若不相同，则说明两个字符串不是同构的。 代码：123456789101112class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: dict_tmp = {} for index, ch in enumerate(s): if ch in dict_tmp: if dict_tmp[ch] != t[index]: return False elif t[index] in dict_tmp.values(): return False else: dict_tmp[ch] = t[index] return True","link":"/b8f4e836/"},{"title":"Daily LeetCode 766. Toeplitz Matri","text":"https://leetcode.com/problems/toeplitz-matrix/ Easy 问题描述：A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz. Example 1: 1234567891011Input:matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2]]Output: TrueExplanation:In the above grid, the diagonals are:&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.In each diagonal all elements are the same, so the answer is True. Example 2: 12345678Input:matrix = [ [1,2], [2,2]]Output: FalseExplanation:The diagonal &quot;[1, 2]&quot; has different elements. Note: matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99]. Follow up: What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once? 题目分析：题目给出了一个Toeplitz矩阵的概念，这种矩阵每一条从左上到右下的对角线上的元素都相等。 最简单的解法就是一一对比，从左上角开始遍历整个矩阵，若当前元素坐标为[i, j]，那么对角线的下一个元素坐标为[i+1, j+1]，当遇到不想等的元素时，返回False即可。 第二种解法是将矩阵切片，给定矩阵：$$\\left[\\begin{matrix}1&amp;2&amp;3&amp;4\\2&amp;1&amp;2&amp;3\\3&amp;2&amp;1&amp;2\\4&amp;3&amp;2&amp;1\\end{matrix}\\right]$$我们可以观察到，只要第i行的[:-1]与第i+1行的[1:]相等，就能确保整个矩阵的每条正对角线都相等。 代码：解法1: 1234567class Solution: def isToeplitzMatrix(self, matrix: List[List[int]]) -&gt; bool: for i in range(len(matrix) - 1): for j in range(len(matrix[0]) - 1): if matrix[i][j] != matrix[i + 1][j + 1]: return False return True 解法2: 123456class Solution: def isToeplitzMatrix(self, matrix: List[List[int]]) -&gt; bool: for row in range(len(matrix) - 1): if matrix[row][:-1] != matrix[row + 1][1:]: return False return True","link":"/4b6a6a21/"},{"title":"746. Min Cost Climbing Stairs","text":"https://leetcode.com/problems/min-cost-climbing-stairs/ Easy 问题描述：On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: 123Input: cost = [10, 15, 20]Output: 15Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2: 123Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]Output: 6Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. 题目分析：这是一道“爬楼梯”的问题，这个楼梯每次可以走一格或者两格，每一格都有对应的花费，从第一格或者第二格的位置出发，我们需要找到登顶时的最低花费。 这一题是一个简单的动态规划问题，有两种走法可以到达第i格：从第i-1格出发，或者从第i-2格出发。因此，到达第i格的最低花费为：dp[i]=min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])，需要注意，第一格和第二格的花费均为0。 代码：123456class Solution: def minCostClimbingStairs(self, cost: List[int]) -&gt; int: dp = [0] * (len(cost) + 1) for i in range(2, len(cost) + 1): dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) return dp[len(cost)] 补充：上述代码的空间复杂度为O(n)，可以通过用三个变量保存每一步的花费来减少空间占用，代码如下： 123456789class Solution: def minCostClimbingStairs(self, cost: List[int]) -&gt; int: n=len(cost) first_cost, second_cost = 0, 0 for i in range(2, n+1): third_cost = min(second_cost+cost[i-1], first_cost+cost[i-2]) first_cost = second_cost second_cost = third_cost return third_cost","link":"/f6ea394f/"},{"title":"Daily LeetCode 144. Binary Tree Preorder Traversal","text":"https://leetcode.com/problems/binary-tree-preorder-traversal/ Medium 问题描述：Given a binary tree, return the preorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? 题目分析：这条题目是很经典的问题，前序遍历二叉树。 前序遍历思想：根-&gt;左-&gt;右 根据这种思路，我们能够很容易地写出递归版本，主要来讨论非递归版本： 从root出发，对于任意节点，我们直接访问，再判断该节点是否有左子树，若存在左子树，则执行上述步骤，直到左子树为空。左子树为空时，我们对右子树执行上述操作。为了能够在访问完左子树后继续访问右子树，我们需要一个栈来保存根节点。 访问节点具体步骤： 将该节点入栈，并将当前节点置为左孩子节点 判断当前节点（左孩子节点）是否为空，若为空，取出栈顶节点，将栈顶节点的右孩子节点置为当前节点；否则，重复步骤1，直到左孩子为空或是栈为空。 代码：递归： 12345678class Solution: def preorder_traversal(root): res = [] if root != None: res.append(root.val) preorder_traversal(root.left) preorder_traversal(root.right) return res 非递归： 12345678910111213class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: current_node = root stack = [] res = [] while current_node != None or len(stack) != 0: if current_node != None: stack.append(current_node) res.append(current_node.val) current_node = current_node.left else: current_node = stack.pop().right return res","link":"/7604570b/"},{"title":"Daily LeetCode 179. Largest Number","text":"https://leetcode.com/problems/largest-number/ Medium 问题描述：Given a list of non negative integers, arrange them such that they form the largest number. Example 1: 12Input: [10,2]Output: &quot;210&quot; Example 2: 12Input: [3,30,34,5,9]Output: &quot;9534330&quot; Note: The result may be very large, so you need to return a string instead of an integer. 题目分析：给定一个正数列表，用这些正数组成一个最大的数。 起初我的思路是将正数列表转换为字符串列表，按照字典序对列表进行排序，再将排完序的列表拼接返回即可，但这种方法不能处理例如[18,180]这样的例子，正确答案应该是18180，但实际会输出18018。 我们可以用类似于冒泡排序的思路来解决这个问题，冒泡排序是比较前后两个数的大小，在这个问题中，由于要保证最终组成的数最大，因此对于[a, b]，我们需要比较a+b与b+a之间的关系，这里的加法指的是字符串加法，即我们需要比较是a在前比较大还是b在前比较大。通过自定义比较函数来实现上述比较，关于python自定义比较函数，可以查看这篇文章：Python Tricks and Tips(Continually updated) 还有一个注意点是对元素全部为0的列表的处理，我们可以调用lstrip()方法将所得字符串左边的0全部去除，在返回结果时，若字符串为空，则直接返回'0'。 代码：1234567891011from functools import cmp_to_keyclass Solution: def largestNumber(self, nums: List[int]) -&gt; str: def ch_cmp(a, b): return int(b + a) - int(a + b) nums = sorted([str(num) for num in nums], key=cmp_to_key(ch_cmp)) res = ''.join(nums) return res.lstrip('0') or '0'","link":"/934cfa66/"},{"title":"Python Tricks and Tips(Continually updated)","text":"最近在网上看到了一篇介绍python小技巧的英文文章，把它==翻译整理==到这里，方便以后自己查阅；同时，以后学习中遇到的一些python小技巧，我也会整理到这篇文章里。 原文地址：https://medium.com/better-programming/20-python-snippets-you-should-learn-today-8328e26ff124 记住一些python编程小技巧能够有助于我们的编码，同时也能节省一些搜索的时间。 Python Version: 3.5.2 反转字符串 通过切片操作实现字符串反转 123456789# 通过切片操作实现字符串反转my_string = &quot;ABCDE&quot;reversed_string = my_string[::-1]print(reversed_string)# Output# EDCBA python中list的切片规则是[start, stop, step]，那么[::-1]就是：我们从开始到结束遍历整个list，同时遍历步长step为-1，遍历过程即为从位置[-1]遍历到位置[-length - 1]，这样保存下来的list，就是原来字符串的逆序。 2.将字符串转换为标题格式（每个单词首字母大写）调用title()方法即可 123456789my_string = &quot;my name is chaitanya baweja&quot;# 调用string类的title方法new_string = my_string.title()print(new_string)# Output# My Name Is Chaitanya Baweja 3.找到字符串中的唯一元素我们可以利用以下的代码找到字符串中的唯一元素 1234567891011my_string = &quot;aavvccccddddeee&quot;# 将字符串转换为集合temp_set = set(my_string)# temp_set: {'a', 'v', 'c', 'd', 'e'}# 使用join方法将集合拼接为字符串new_string = ''.join(temp_set)print(new_string)# Output: avcde python中的集合是一个无序的不重复元素序列，而join()方法可以将字符串序列拼接起来。 4.打印字符串或者列表n次我们可以使用*n操作来打印字符串或列表n次，这种方法也能够用在初始化列表上。 12345678910n = 3 # 重复次数my_string = &quot;abcd&quot;my_list = [1, 2, 3]print(my_string * n)# abcdabcdabcdprint(my_string*n)# [1, 2, 3, 1, 2, 3, 1, 2, 3] 初始化长度为n的列表： 1new_list = [0] * n 5.对列表元素操作（列表解析-list comprehension）我认为这是python中一项非常优雅的操作，通过一行代码，我们就可以基于原有列表或是其他数据创建一个新的列表。 例如下例中，通过将列表中每个元素乘2，创建一个新的列表 12345678# 将列表中每个元素乘2original_list = [1, 2, 3, 4]new_list = [2 * x for x in original_list]print(new_list)# [2, 4, 6, 8] 我们可以在列表解析中加入判断： 1234old_list = [1, 2, 3, 4]new_list = [i**3 if i % 2 == 0 else i**2 for i in old_list]print(new_list) # Output: [1, 8, 9, 64] 上述代码将原列表中的偶数立方、奇数平方，生成了新的列表。 我们可以在列表解析过程中加入多个循环： 12345678a = [1, 2, 3, 4]b = [10, 11]cart_prod = [(i, j) for i in a for j in b]print cart_prod# Output:# [(1, 10), (1, 11), (2, 10), (2, 11), (3, 10), (3, 11), (4, 10), (4, 11)] 上述一行代码生成了a、b两个列表间的笛卡尔积。 6.交换两个变量的值相较于其他语言，python中变量值交换操作属实简单，对多个变量的赋值也很清晰： 1234567# 为a，b赋值a, b = 1, 2a, b = b, aprint(a) # 2print(b) # 1 7.切分字符串（string-&gt;list）通过调用.split()方法实现对字符串的切分，通过传递参数，我们可以选择切分的分隔符： 12345678910string_1 = &quot;My name is Chaitanya Baweja&quot;string_2 = &quot;sample/ string 2&quot;# 默认按空格切分print(string_1.split())# ['My', 'name', 'is', 'Chaitanya', 'Baweja']# 通过传递参数，按‘/’切分print(string_2.split('/'))# ['sample', ' string 2'] 8.将字符串列表合并为字符串（list-&gt;string）我们在3中介绍过使用join()拼接字符串： 12345678910111213list_of_strings = ['My', 'name', 'is', 'Chaitanya', 'Baweja']# 默认用空格拼接listprint(''.join(list_of_strings))# Output# My name is Chaitanya Baweja# 用逗号拼接listprint(','.join(list_of_strings))# Output# My,name,is,Chaitanya,Baweja 9.判断字符串是否为回文串我们已经介绍了反转字符串的方法，只需要判断反转后的字符串与原字符串是否相等即可： 123456789my_string = &quot;abcba&quot;if my_string == my_string[::-1]: print(&quot;palindrome&quot;)else: print(&quot;not palindrome&quot;)# Output# palindrome 10.列表中的元素频率统计列表中元素出现的频率有很多方法，我们可以使用字典，也可以使用Counter类。 Counter类能够记录容器中每个元素的频率，它返回一个字典，字典中的键值对为：{元素:元素出现次数} 123456789101112131415# finding frequency of each element in a listfrom collections import Countermy_list = ['a', 'a', 'b', 'b', 'b', 'c', 'd', 'd', 'd', 'd', 'd']count = Counter(my_list) # defining a counter objectprint(count) # Of all elements# Counter({'d': 5, 'b': 3, 'a': 2, 'c': 1})print(count['b']) # of individual element# 3# 通过调用most_common()方法获取出现频率最高的元素print(count.most_common(1)) # [('d', 5)] 11.判断两个字符串是否为同字母异构这是Counter类的奇妙应用之一，可以来判断某个字符串是否是重新调换另一个字符串字符位置而成 123456789from collections import Counterstr_1, str_2, str_3 = &quot;acbde&quot;, &quot;abced&quot;, &quot;abcda&quot;cnt_1, cnt_2, cnt_3 = Counter(str_1), Counter(str_2), Counter(str_3)if cnt_1 == cnt_2: print('1 and 2 anagram')if cnt_1 == cnt_3: print('1 and 3 anagram') 12.try-except-else代码块在python中，可以通过try-except代码块来处理异常。当没有异常发生时，我们可以通过增加一个else代码块来继续执行代码；或者通过增加一个finally代码块来忽略异常，继续执行： 1234567891011121314a, b = 1,0try: print(a/b) # exception raised when b is 0except ZeroDivisionError: print(&quot;division by zero&quot;)else: print(&quot;no exceptions raised&quot;)finally: print(&quot;Run this always&quot;)# Output# division by zero# Run this always 13.调用Enumerate方法获取下标与元素值我们可以通过Enumerate方法在一次循环中同时获取元素下标与值： 12345678910my_list = ['a', 'b', 'c', 'd', 'e']for index, value in enumerate(my_list): print('{0}: {1}'.format(index, value))# 0: a# 1: b# 2: c# 3: d# 4: e 14.查看对象的内存占用12345678import sysnum = 21print(sys.getsizeof(num))# In Python 2, 24# In Python 3, 28 15.合并字典12345678dict_1 = {'apple': 9, 'banana': 6}dict_2 = {'banana': 4, 'orange': 8}combined_dict = {**dict_1, **dict_2}print(combined_dict)# Output# {'apple': 9, 'banana': 4, 'orange': 8} 16.统计代码执行时间1234567891011import timestart_time = time.time()# 开始执行a, b = 1,2c = a+ b# 执行结束end_time = time.time()time_taken_in_micro = (end_time- start_time)*(10**6)print(&quot; Time taken in micro_seconds: {0} ms&quot;).format(time_taken_in_micro) 17.将高维数组转换为一维123456789101112131415from iteration_utilities import deepflatten# 深度为1的列表def flatten(l): return [item for sublist in l for item in sublist]l = [[1,2,3],[3]]print(flatten(l))# [1, 2, 3, 3]# 未知深度的列表l = [[1,2,3],[4,[5],[6,7]],[8,[9,[10]]]]print(list(deepflatten(l, depth=3)))# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 我们还可以使用Numpy库转换数组。 numpy.flatten(order='C')方法：默认参数为’C’，’C’表示按行顺序优先转换；’F’是指列顺序优先转换；’A’是指，若列表在内存中连续存储，则按列顺序优先转换；反之，则按行顺序优先转换；’K’是指按列表元素在内存出现的顺序转换。 12345a = np.array([[1,2], [3,4]])a.flatten()array([1, 2, 3, 4])a.flatten('F')array([1, 3, 2, 4]) 18.从列表随机采样12345678import randommy_list = ['a', 'b', 'c', 'd', 'e']num_samples = 2samples = random.sample(my_list,num_samples)print(samples)# [ 'a', 'e'] this will have any 2 random values 还可以调用secrets库来生成随机样本： 12345678910import secrets secure_random = secrets.SystemRandom() my_list = ['a', 'b', 'c', 'd', 'e']num_samples = 2samples = secure_random.sample(my_list, num_samples)print(samples)# [ 'e', 'd'] this will have any 2 random values 19.integer-&gt;list123456num = 123456list_of_digits = list(map(int, str(num)))print(list_of_digits)# [1, 2, 3, 4, 5, 6] 20.判断列表是否存在重复元素基于列表生成集合，通过判断列表长度与集合长度是否相等，即可判断列表是否存在重复元素。 1234567891011def unique(l): if len(l)==len(set(l)): print(&quot;All elements are unique&quot;) else: print(&quot;List has duplicates&quot;)unique([1,2,3,4])# All elements are uniqueunique([1,1,2,3])# List has duplicates 21.自定义比较函数对列表排序当我们想要用其他方式而不是数字大小顺序对列表排序时，我们可以通过cmp_to_key转换比较方式，下例中，我们将自定义函数传递给sorted()函数： 1234567def custom_sort(nums) -&gt; str: def custom_cmp(a, b): return a**2 - b**2 nums = sorted([num for num in nums], key=cmp_to_key(custom_cmp)) return nums 上述代码段能够按列表元素的平方大小进行排序。","link":"/5dffcfb0/"},{"title":"Daily LeetCode 565. Array Nesting","text":"https://leetcode.com/problems/array-nesting/ Medium 问题描述A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S. Example 1: 1234567Input: A = [5,4,0,3,1,6,2]Output: 4Explanation: A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.One of the longest S[K]:S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0} Note: N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1]. 题目分析：给定一个长度为N的数组，数组包含从0～N-1的所有元素，定义一个序列S，S的构成方式如下：S[i]={A[i], A[A[i]], A[A[A[i]]], ... }，直到遇到重复元素，构造过程结束。我们需要找一个基于数组构造的、长度最长的序列S。 解决这题的思路很简单，我们只需要按照题目描述的那样，从不同的位置出发，分别构造序列S，比较每个序列的长度，返回最长的长度即可。 这个问题的关键在于记录当前位置是否被访问过，比较常用的做法是初始化一个访问数组，每访问一个元素，就将访问数组对应位置置为True，但这种方式会导致超时，我们有两种方法解决超时问题： 将访问数组放到循环外，这样，当从新的位置出发时，遇到了已访问过的元素，就可以直接跳过，因为给出的数组不存在重复元素，从前一个位置出发得到的序列长度必然大于从后面出发得到的序列。 由于给定数组中全是大于0的元素，我们可以将已访问过的元素置为-1，这样也能够起到记录是否访问过的作用，不需要另外的访问数组，还减小了空间复杂度。 代码：方法1： 12345678910111213class Solution: def arrayNesting(nums): res = -1 count = 0 seen = [False] * len(nums) for i in range(len(nums)): while not seen[i]: seen[i] = True i = nums[i] count += 1 res = max(res, count) count = 0 return res 方法2: 123456789101112class Solution: def arrayNesting(self, nums: List[int]) -&gt; int: res = -1 count = 0 for i in range(len(nums)): while nums[i] &gt;= 0: tmp_i, nums[i] = nums[i], -1 i = tmp_i count += 1 res = max(res, count) count = 0 return res","link":"/3693d24c/"},{"title":"Daily LeetCode 784. Letter Case Permutatio","text":"https://leetcode.com/problems/letter-case-permutation/ Easy 问题描述：Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. 123456789Examples:Input: S = &quot;a1b2&quot;Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]Input: S = &quot;3z4&quot;Output: [&quot;3z4&quot;, &quot;3Z4&quot;]Input: S = &quot;12345&quot;Output: [&quot;12345&quot;] Note: S will be a string with length between 1 and 12. S will consist only of letters or digits. 题目分析：给定一个由字母和数字组成的字符串，我们需要返回一个基于所有字母大小写全排列构成的字符串列表。 这一题对数字不需要任何的处理，只要简单加上即可，主要还是对字母的处理。我们可以利用python中列表操作的特性来解决这条题目。首先，对字符串进行遍历，遇到字母ch时，将ch的大小写分别添加到结果列表中。 代码：123456789class Solution: def letterCasePermutation(self, S: str) -&gt; List[str]: res = [''] for ch in S: if ch.isalpha(): res = [res_sub + ch.upper() for res_sub in res] + [res_sub + ch.lower() for res_sub in res] else: res = [res_sub + ch for res_sub in res] return res","link":"/efe6bc62/"},{"title":"Daily LeetCode 1143. Longest Common Subsequence","text":"https://leetcode.com/problems/longest-common-subsequence/submissions/ Medium 问题描述：Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A common subsequence of two strings is a subsequence that is common to both strings. If there is no common subsequence, return 0. Example 1: 123Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; Output: 3 Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3. Example 2: 123Input: text1 = &quot;abc&quot;, text2 = &quot;abc&quot;Output: 3Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3. Example 3: 123Input: text1 = &quot;abc&quot;, text2 = &quot;def&quot;Output: 0Explanation: There is no such common subsequence, so the result is 0. Constraints: 1 &lt;= text1.length &lt;= 1000 1 &lt;= text2.length &lt;= 1000 The input strings consist of lowercase English characters only. 题目分析：这一题是要找出两个字符串之间的最长公共子串。 思路一： 分别找出两个字符串的子串，然后找出最长的公共子串即可，这种暴力解法在思路上很直接，但是求子串的过程会耗费大量的时间和空间，因此这种方法并不适合。 思路二： 这题其实是一道典型的用动态规划解决的题目，在解决两个字符串相关的问题时，通常需要维护一个二维数组，来描述两个字符串之间的关系。 我们初始化一个dp数组，dp[i][j]表示当前情况下最长的公共子串长度，即text1前i个元素与text2前j个元素能构成的最长公共子串长度（i，j不包括在内）。 接着我们来考虑状态转移方程，更新dp[i][j]时应当考虑两种情况：第一种是当前遍历的字符相等的情况，即text1[i]==text2[j]，此时，dp[i][j]=dp[i-1][j-1]+1，即text1前i-1个元素与text2前j-1个元素能构成的最长公共子串长度加1；第二种情况是当前遍历的字符不想等的情况，由于字符不等，因此我们只能在dp[i-1][j], dp[i][j-1]中选一个最大值，因为我们此时不能扩展公共子串了，此时，dp[i][j]=max(dp[i-1][j], dp[i][j-1])。 以Example1为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960current text1 index: 1, current text2 index: 1, equalcurrent char of text1: a, current char of text2: acurrent_text1: a, current_text2: adp[i][j]: 1, dp[i-1][j-1]: 0current text1 index: 1, current text2 index: 2, not equalcurrent char of text1: a, current char of text2: ccurrent_text1: a, current_text2: acdp[i][j]: 1, dp[i-1][j]: 0, dp[i][j-1]: 1current text1 index: 1, current text2 index: 3, not equalcurrent char of text1: a, current char of text2: ecurrent_text1: a, current_text2: acedp[i][j]: 1, dp[i-1][j]: 0, dp[i][j-1]: 1current text1 index: 2, current text2 index: 1, not equalcurrent char of text1: b, current char of text2: acurrent_text1: ab, current_text2: adp[i][j]: 1, dp[i-1][j]: 1, dp[i][j-1]: 0current text1 index: 2, current text2 index: 2, not equalcurrent char of text1: b, current char of text2: ccurrent_text1: ab, current_text2: acdp[i][j]: 1, dp[i-1][j]: 1, dp[i][j-1]: 1current text1 index: 2, current text2 index: 3, not equalcurrent char of text1: b, current char of text2: ecurrent_text1: ab, current_text2: acedp[i][j]: 1, dp[i-1][j]: 1, dp[i][j-1]: 1current text1 index: 3, current text2 index: 1, not equalcurrent char of text1: c, current char of text2: acurrent_text1: abc, current_text2: adp[i][j]: 1, dp[i-1][j]: 1, dp[i][j-1]: 0current text1 index: 3, current text2 index: 2, equalcurrent char of text1: c, current char of text2: ccurrent_text1: abc, current_text2: acdp[i][j]: 2, dp[i-1][j-1]: 1current text1 index: 3, current text2 index: 3, not equalcurrent char of text1: c, current char of text2: ecurrent_text1: abc, current_text2: acedp[i][j]: 2, dp[i-1][j]: 1, dp[i][j-1]: 2current text1 index: 4, current text2 index: 1, not equalcurrent char of text1: d, current char of text2: acurrent_text1: abcd, current_text2: adp[i][j]: 1, dp[i-1][j]: 1, dp[i][j-1]: 0current text1 index: 4, current text2 index: 2, not equalcurrent char of text1: d, current char of text2: ccurrent_text1: abcd, current_text2: acdp[i][j]: 2, dp[i-1][j]: 2, dp[i][j-1]: 1current text1 index: 4, current text2 index: 3, not equalcurrent char of text1: d, current char of text2: ecurrent_text1: abcd, current_text2: acedp[i][j]: 2, dp[i-1][j]: 2, dp[i][j-1]: 2current text1 index: 5, current text2 index: 1, not equalcurrent char of text1: e, current char of text2: acurrent_text1: abcde, current_text2: adp[i][j]: 1, dp[i-1][j]: 1, dp[i][j-1]: 0current text1 index: 5, current text2 index: 2, not equalcurrent char of text1: e, current char of text2: ccurrent_text1: abcde, current_text2: acdp[i][j]: 2, dp[i-1][j]: 2, dp[i][j-1]: 1current text1 index: 5, current text2 index: 3, equalcurrent char of text1: e, current char of text2: ecurrent_text1: abcde, current_text2: acedp[i][j]: 3, dp[i-1][j-1]: 2 代码：12345678910class Solution: def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int: dp = [[0 for _ in range(len(text2) + 1)] for __ in range(len(text1) + 1)] for i in range(1, len(text1) + 1): for j in range(1, len(text2) + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[-1][-1]","link":"/b7b16ed3/"},{"title":"Daily LeetCode 2. Add Two Numbers","text":"https://leetcode.com/problems/add-two-numbers/ Medium 问题描述：You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 题目分析及代码：LeetCode上的第二条题目，一道与链表操作相关的题目，两个链表，将对应位置上的数相加，超过十则进位，输出最终得到的链表。 思路1: 由于链表保存的顺序就是从低位到高位，因此我们直接遍历两个列表，按题目描述那样，对应位置相加，只需要注意最后一位相加需要进位的情况，例如(5) + (5)，在遍历完成后需要对这种情况做额外处理，使得最终输出为0-&gt;1而不是0。 代码： 12345678910111213141516171819class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: res = point = ListNode(0) extra = 0 while l1 != None or l2 != None: l1_ele = l1.val if l1 != None else 0 l2_ele = l2.val if l2 != None else 0 sum = l1_ele + l2_ele + extra extra = 1 if sum &gt;= 10 else 0 point.next = ListNode(int(sum%10)) point = point.next if l1 != None: l1 = l1.next if l2 != None: l2 = l2.next if extra == 1: point.next = ListNode(1) return res.next 思路2: 可以通过递归来减少空间复杂度 1234567891011121314class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if l1 != None and l2 != None: return elif (l1 and l2) == None: return l1 or l2 else: if l1.val + l2.val &lt; 10: res = ListNode(l1.val + l2.val) res.next = self.addTwoNumbers(l1.next, l2.next) else: res = ListNode(l1.val + l2.val - 10) res.next = self.addTwoNumbers(l1.next, self.addTwoNumbers(l2.next, ListNode(1))) return res","link":"/4db0f31d/"},{"title":"Daily LeetCode 445. Add Two Numbers II","text":"https://leetcode.com/problems/add-two-numbers-ii/ Medium 问题描述You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: 12Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 题目分析这一题与昨天的题目有一些不同，昨天的题目链表是从低位到高位排列的，而Add two numbers II是从高位向低位排列的，因此我们需要先将两个链表反转，再按昨天的解法处理，处理完之后，再将得到的链表反转输出。 如果不能对链表进行反转操作，我们可以通过栈来解决这个问题，分别遍历两个链表，将元素入栈，再对栈操作，采用与Add two numbers相同的解法，不同的是，构建链表时，我们需要采用头插法。 代码：反转链表： 12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: def reverse_node(l): if not l or not l.next: return l pre = None while l: tmp = l.next l.next = pre pre = l l = tmp return pre res = point = ListNode(0) extra = 0 l1 = reverse_node(l1) l2 = reverse_node(l2) while l1 != None or l2 != None: l1_ele = l1.val if l1 != None else 0 l2_ele = l2.val if l2 != None else 0 sum = l1_ele + l2_ele + extra extra = 1 if sum &gt;= 10 else 0 point.next = ListNode(int(sum%10)) point = point.next if l1 != None: l1 = l1.next if l2 != None: l2 = l2.next if extra: point.next = ListNode(1) return reverse_node(res.next) 栈： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; stack1 = [] stack2 = [] while l1: stack1.append(l1.val) l1 = l1.next while l2: stack2.append(l2.val) l2 = l2.next res = ListNode() extra = 0 while stack1 and stack2: sum = stack1.pop() + stack2.pop() + extra extra = 1 if sum &gt;= 10 else 0 tmp = res res = ListNode(int(sum % 10)) res.next = tmp l = stack1 if stack1 else stack2 while l: sum = l.pop() + extra extra = 1 if sum &gt;= 10 else 0 tmp = res res = ListNode(int(sum % 10)) res.next = tmp if extra: tmp = res res = ListNode(1) res.next = tmp return res.next","link":"/20136ace/"},{"title":"Daily LeetCode 367. Valid Perfect Square","text":"https://leetcode.com/problems/valid-perfect-square/ Easy 问题描述：Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: 12Input: 16Output: true Example 2: 12Input: 14Output: false 题目分析及代码：给定一个正数，需要判断这个正数是不是一个完全平方数。不能调用sqrt方法 思路1: 要想知道这个正数num是不是完全平方，我们只需要计算1~num的平方，看它是不是与num相等即可，为了提高查找的效率，我们用二分查找的方式来判断： 1234567891011121314class Solution: def isPerfectSquare(self, num: int) -&gt; bool: left, right = 0, num while right &gt;= left: mid = left + (right - left) // 2 if mid**2 == num: return True elif mid**2 &lt; num: left = mid + 1 else: right = mid - 1 return False Ps.二分查找mid取值时使用left+(right - left)//2可以避免整数溢出的问题。 思路2: 所有的完全平方数都能够转换为奇数列的和：$n=1+3+5+…+(2n-1)$ 12345678class Solution: def isPerfectSquare(self, num: int) -&gt; bool: i = 1 while num &gt; 0: num -= i i += 2 return num == 0 思路3: 牛顿迭代法 令$f(x) = x^2-a$，$f^{‘}(x)=2x$，牛顿迭代式为：$$x_{n+1}=x_n - \\frac{x^2_n - a}{2x_n} = \\frac{1}{2}(x_n + \\frac{a}{x_n})$$ 12345678class Solution: def isPerfectSquare(self, num: int) -&gt; bool: r = num while r*r &gt; num: r = (r + num/r) // 2 return r*r == num","link":"/669e6940/"},{"title":"Daily LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal","text":"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ Medium 问题描述Given inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12inorder = [9,3,15,20,7]postorder = [9,15,7,20,3] Return the following binary tree: 12345 3 / \\9 20 / \\ 15 7 题目分析及代码给定二叉树的中序和后序遍历结果，构造二叉树。 方法一 中序遍历的遍历顺序是左中右，后序遍历的遍历顺序是左右中。我们可以很容易地发现，后序遍历的最后一个元素就是二叉树的根元素，根据这个根元素以及中序遍历的结果，我们就能够获得左右子树的遍历结果；此时，子问题变成了根据左右子树的中序、后序遍历结果构造二叉树，我们通过递归即可解决这个问题。 代码： 12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: def restoreTree(inorder, in_start, in_end, postorder, post_start, post_end): if in_start &gt; in_end or post_start &gt; post_end: return None treeNode = TreeNode(postorder[post_end]) for i in range(in_end + 1): if inorder[i] == postorder[post_end]: treeNode.left = restoreTree(inorder, in_start, i - 1, postorder, post_start, post_start + i - in_start - 1) treeNode.right = restoreTree(inorder, i + 1, in_end, postorder, post_start + i - in_start, post_end - 1) return treeNode tree = restoreTree(inorder, 0, len(inorder) - 1, postorder, 0, len(postorder) - 1) return tree LeetCode论坛看到的方法2 没有右子树的二叉树中序和后序遍历结果相同： 12345 1 / 2中序：1，2后序：1，2 但是，没有左子树的二叉树中序和后序遍历结果是不同的： 12345 1 \\ 2中序：1，2后序：2，1 上面我们已经提到过，后序遍历的最后一个元素就是当前树的根节点，因此，我们可以从右向左、根据遍历结果构造左右子树。 如果中序和后序的值相同，那么当前值一定是左子树，否则就是右子树，我们将建立的新节点都存储在栈中，当作当前大小为1的子树的根节点，这样，在遍历完成后根据栈建立二叉树。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, inorder, postorder): if len(inorder) == 0: return None root = TreeNode(postorder[-1]) stack = [root] in_index = len(inorder) - 1 # 根节点已经保存到栈中，因此，后序遍历的最后一个元素无需处理 post_index = len(postorder) - 2 # 比较中序最右元素和栈顶元素 while True: # 栈顶元素与中序遍历的最右元素相等 # 第一次出现这种情况时，意味着我们遍历到了中序序列中的根节点 # 这意味着我们已经建立完了右子树，并且这些节点已经保存在了栈中 # 我们无视这些节点即可，右子树建立过程在'else'中 if stack[-1].val == inorder[in_index]: n = stack.pop() in_index -= 1 if in_index == -1: break # 越过中序遍历序列中的所有右子树节点 if stack and inorder[in_index] == stack[-1].val: continue # 建立左子树 # n是从栈中取出的当前节点 n.left = TreeNode(postorder[post_index]) post_index -= 1 stack.append(n.left) # 栈顶元素与中序最右元素不同时，我们需要建立右子树 else: n = TreeNode(postorder[post_index]) post_index -= 1 stack[-1].right = n stack.append(n) return root","link":"/f19b3458/"},{"title":"Daily LeetCode 94. Binary Tree Inorder Traversal","text":"https://leetcode.com/problems/binary-tree-inorder-traversal/ Medium 问题描述：Given a binary tree, return the inorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? 思路及代码：这一题是要中序遍历二叉树 方法1: 采用递归的方式进行遍历 1234567891011def inorderTraversal(root): def traversal(root, res): if root: traversal(root.left, res) res.append(root.val) traversal(root.right, res) res = [] traversal(root, res) return res 方法2: 采用非递归的方式进行中序遍历 1234567891011121314151617class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return None stack = [] res = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() res.append(root.val) root = root.right return res","link":"/670f617/"},{"title":"Daily LeetCode 376. Wiggle Subsequence","text":"https://leetcode.com/problems/wiggle-subsequence/ Medium 问题描述：A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: 123Input: [1,7,4,9,2,5]Output: 6Explanation: The entire sequence is a wiggle sequence. Example 2: 123Input: [1,17,5,10,13,15,10,5,16,8]Output: 7Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8]. Example 3: 12Input: [1,2,3,4,5,6,7,8,9]Output: 2 Follow up:Can you do it in O(n) time? 题目分析及代码：题目给出了一个称作wiggle sequence的定义，这是一个摆动序列，满足nums[i-1]&lt;nums[i]&gt;nums[i+1]，我们需要从给定输入中找出一个最长的子摆动序列。 方法1: 对于数组中的每个元素，可能有三种状态： 后一个数大于这个数，此时记做up 后一个数小于这个数，此时记做down 后一个数等于这个数 我们维护两个数组，来记录当前情况下（index=i）wiggle sequence的最长长度： 后一个数大于当前数时，这个序列是“向上摆”的，想要确保该序列是摆动序列，我们需要确保当前数与前一个数的关系是“向下摆”，即当前数小于前一个数。此时更新up数组，up[i]=down[i-1]+1；同时，down数组在当前位置的值与先前相同，不做更新，down[i]=down[i-1] 后一个数小于当前数时，与上述情况刚好相反，此时，up[i]=up[i-1]，down[i]=up[i-1]+1 两数相等时，不做任何更新操作，up[i]=up[i-1], down[i]=down[i-1] 12345678910111213141516def wiggleMaxLength(nums): up = [1 for i in range(len(nums))] down = [1 for i in range(len(nums))] for i in range(1, len(nums)): if nums[i] &gt; nums[i - 1]: up[i] = down[i - 1] + 1 down[i] = down[i - 1] elif nums[i] &lt; nums[i - 1]: down[i] = up[i - 1] + 1 up[i] = up[i - 1] else: up[i], down[i] = up[i - 1], down[i - 1] return max(up[-1], down[-1]) 方法2: 贪心策略，维护up和down两个变量，均初始化为1，遍历数组，当前元素大于前一个元素时，up = down + 1；当前元素小于前一个元素时，down = up + 1。 与动态规划思想相同，但节省了空间。 123456789def wiggleMaxLength(nums): up, down = 1, 1 for i in range(1, len(nums)): if nums[i] &gt; nums[i - 1]: up = down + 1 elif nums[i] &lt; nums[i - 1]: down = up + 1 return min(len(nums), max(up, down))","link":"/bbfad486/"},{"title":"Daily LeetCode 861. Score After Flipping Matrix","text":"https://leetcode.com/problems/score-after-flipping-matrix/ Medium 问题描述：We have a two dimensional matrix A where each value is 0 or 1. A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s. After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score. Example 1: 12345Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]Output: 39Explanation:Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 Note: 1 &lt;= A.length &lt;= 20 1 &lt;= A[0].length &lt;= 20 A[i][j] is 0 or 1. 题目分析及代码：给定一个矩阵A，我们可以对矩阵的行或列进行取反操作，要求操作完成后，把每一行当作二进制数，得到的和最大。 了解二进制就能明白，想要确保一个二进制数足够大，那么首先要确保该二进制数的首位为1，在这个题目中，我们先对矩阵的行进行处理，反转所有首位为0的行；再对列进行处理，对列处理时，我们不再关注首位的情况，我们关注一列中0和1的个数，这是因为最终的计算是看行的，列中1的数量多，那么总和自然更大。 以Example 1为例： 我们先对行进行处理，由于首位均为1，因此不变：$$A=\\left[\\begin{array}{ccc}1,&amp;1,&amp;0,&amp;0\\1,&amp;0,&amp;1,&amp;0\\1,&amp;1,&amp;0,&amp;0\\end{array}\\right]$$接着，我们对列进行处理，反转第三列和第四列：$$A=\\left[\\begin{array}{ccc}1,&amp;1,&amp;1,&amp;1\\1,&amp;0,&amp;0,&amp;1\\1,&amp;1,&amp;1,&amp;1\\end{array}\\right]$$代码： 1234567891011121314151617181920212223from collections import Counterclass Solution: def matrixScore(self, A: List[List[int]]) -&gt; int: for i in range(len(A)): if A[i][0] == 0: A[i] = [0 if A[i][_] == 1 else 1 for _ in range(len(A[i]))] for i in range(len(A[0])): column = [col[i] for col in A] counter = Counter(column) if counter[0] &gt; counter[1]: column = [0 if column[_] == 1 else 1 for _ in range(len(column))] for r in range(len(A)): A[r][i] = column[r] res = 0 for row in A: row.reverse() for i in range(len(A[0])): res += (2 ** i) * row[i] return res","link":"/1a28a4c2/"},{"title":"Daily LeetCode 795. Number of Subarrays with Bounded Maximum","text":"https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/ Medium 问题分析：We are given an array A of positive integers, and two positive integers L and R (L &lt;= R). Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R. 1234567Example :Input: A = [2, 1, 4, 3]L = 2R = 3Output: 3Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3]. Note: L, R and A[i] will be an integer in the range [0, 10^9]. The length of A will be in the range of [1, 50000]. 思路及代码：这条题目给定一个数组A，和一个范围[L, R]，要求求出连续非空子串的个数，这个子串的最大值在区间[L, R]内。 思路: 动态规划 维护一个一维的状态数组dp，dp[i]表示以A[i]结尾的数组中，符合条件的子串的个数；设置一个子串开始标志sub_start。 状态转移方程有下列几种情况： 当A[index] &gt; R时： 由于当前元素超出了范围，因此加上这个元素后，子串不符合条件，此时dp[index]=0，同时，将sub_start设置为当前位置的index。 当A[index] &lt; L时： 当前元素小于范围，这个元素对子串数量没有影响，此时dp[index]=dp[index-1] 当L&lt;=A[index]&lt;=R时： 当前元素处于范围内，由于要求构造连续的子串，我们只需要考虑从sub_start到index这个范围内的连续子串，这个范围内的连续子串个数为index-sub_start，因此，dp[index] = index - sub_start 代码： 123456789101112131415class Solution: def numSubarrayBoundedMax(self, A: List[int], L: int, R: int) -&gt; int: dp = [0 for _ in range(len(A))] sub_start = -1 for index, num in enumerate(A): if num &lt; L: dp[index] = dp[index - 1] elif num &gt; R: dp[index] = 0 sub_start = index else: dp[index] = index - sub_start return sum(dp)","link":"/f91f8e0d/"},{"title":"Daily LeetCode 36. Valid Sudoku","text":"https://leetcode.com/problems/valid-sudoku/ Medium 问题描述Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. Example 1: 12345678910111213Input:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true Example 2: 123456789101112131415Input:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9. 思路及代码：这一题是今天早上算法课的测试中做到的题目 数独有三条规则： 每一行都由1～9组成，互不重复 每一列都有1～9组成，互不重复 每一个小的九宫格，也都由1～9组成，互不重复 我们只需要按照这三条规则，对给定的数独进行判断，看该数独是不是符合规则。 我们通过set()方法来判断是否存在重复元素 123456789101112131415161718192021222324252627class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: if board is None or len(board) != 9 or len(board[0]) != 9: return False for i in range(9): row = [_ for _ in board[i] if _ != '.'] if len(row) != len(set(row)): return False for i in range(9): col = [board[_][i] for _ in range(9) if board[_][i] != '.'] if len(col) != len(set(col)): return False for i in range(0, 9, 3): for j in range(0, 9, 3): cell = [] for k in range(3): for p in range(3): num = board[i + k][j + p] if num != '.': cell.append(num) if len(cell) != len(set(cell)): return False return True","link":"/4991a1b7/"},{"title":"Daily LeetCode 5. Longest Palindromic Substring","text":"https://leetcode.com/problems/longest-palindromic-substring/ Medium 问题描述：Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 思路及代码：这一题要求最长回文子串。 中间-&gt;两边： 回文串从中间向两边是镜像的状态，例如abba，中心为bb，或是aba，中心为a。因此，无论长度是奇数还是偶数，回文串都关于中间一个或是两个字符对称。因此，我们只需要遍历一边输入串s，分别考虑以s[i]或s[i]&amp;s[i+1]为中心的最长回文串即可。 我们设置一个辅助函数，接受参数为： s：输入串 start：回文串起点 end：回文串终点 返回当前情况下最长的回文子串。 12345678910111213141516171819202122class Solution: def longestPalindrome(self, s: str) -&gt; str: def expand(s, start, end): while start &gt;= 0 and end &lt;= len(s) - 1 and s[start] == s[end]: start -= 1 end += 1 return s[start + 1:end] if len(s) &lt;= 1 or not s: return s res = s[0:1] for i in range(len(s)): tmp = expand(s, i, i) if len(tmp) &gt; len(res): res = tmp tmp = expand(s, i, i + 1) if len(tmp) &gt; len(res): res = tmp return res 动态规划： 对于这种求子串的问题，我们可以用动态规划的思想来解决，维护一个二维数组dp，dp[i][j]表示以i为起点、j为终点的子串是否为回文串。我们需要考虑三种情况： i=j时，dp[i][j]始终等于1 j=i+1时，此时就是往长度为1的串中添加一个字符，只需要考虑s[i]是不是等于\u0001s[j]，若相等，则为回文串 j&gt;i+1时，此时等价于向以i-1为起点、j+1为终点的字符串两边加字母，我们需要考虑两个条件，一是字符串s[i-1:j+1]是不是回文串，二是待添加的字符s[i]与s[j]是否相等，均满足时，才可以得到一个新的回文串。 在遍历过程中，我们还需要更新变量start和length，当前回文串的长度为i-j+1，在遍历过程中，确保回文串长度最大，同时更行回文串起点，这样能够方便获取结果。 12345678910111213141516class Solution: def longestPalindrome(self, s: str) -&gt; str: if not s: return s dp = [[0] * len(s) for _ in range(len(s))] start, length = 0, 1 for i in range(len(s)): dp[i][i] = 1 for j in range(i): if s[i] == s[j] and (i - j &lt; 2 or dp[j + 1][i - 1]): dp[j][i] = 1 if dp[j][i] and length &lt; i - j + 1: length = i - j + 1 start = j return s[start:start + length]","link":"/2a135485/"},{"title":"Daily LeetCode 53. Maximum Subarray","text":"https://leetcode.com/problems/maximum-subarray/ Medium 问题描述Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 思路及代码：给定一个数组，求和最大的子串。 动态规划： 虽然这一题也是要求子串的问题，但是跟昨天的不同，我们不需要维护二维数组，因为这条题目的最终目的是求和。 我们只需要一个一维数组dp，dp[i]表示nums[0:i]的最大和，状态转移方程：dp[i]=max(dp[i-1] + nums[i], nums[i]) 代码： 1234567class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: dp = [0] * len(nums) for i in range(len(nums)): dp[i] = max(dp[i-1] + nums[i], nums[i]) return max(dp) 我们可以维护一个变量tmp_ans以节省空间，在遍历过程中判断tmp_ans是否小于零，若小于零，则重置tmp_ans为0，即改变求和起点，重新求和。 1234567891011import sysclass Solution: def maxSubArray(self, nums: List[int]) -&gt; int: max_sum = -sys.maxsize - 1 tmp_ans = 0 for i in range(len(nums)): if tmp_ans &lt; 0: tmp_ans = 0 tmp_ans += nums[i] max_sum = max(tmp_ans, max_sum) return max_sum","link":"/80402940/"},{"title":"Daily LeetCode 62. Unique Paths","text":"https://leetcode.com/problems/unique-paths/ Medium 问题描述：A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: 1234567Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down2. Right -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Right Example 2: 12Input: m = 7, n = 3Output: 28 思路及代码：给定一个m x n的方格，起点为左上角，终点为右下角，每次能够向下或者向右走一格，要求求出所有可能的路径数。 这是一题典型的运用动态规划解决的问题，我们可以设置一个二维数组dp[i][j]，表示当前方格到终点的路径条数，以3 x 2的方格为例，这种情况下dp数组如下：$$dp=\\left[\\begin{array}{ccc}3&amp;2&amp;1\\1&amp;1&amp;0\\end{array}\\right]$$在代码编写中，我们要从终点向起点走，将dp数组的最后一列和最后一行设置为1，因为从这些方格出发到终点只有一条路径。在遍历过程中按照dp[i][j] = dp[i][j+1] + dp[i+1][j]更新数组，最终dp[0][0]就是路径数。 1234567891011121314151617class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: if m == 1 and n == 1: return 1 dp = [[0] * m for _ in range(n)] dp[n - 1][m - 1] = 0 for i in range(m - 1): dp[n - 1][i] = 1 for i in range(n - 1): dp[i][m - 1] = 1 for i in range(n - 1, 0, -1): for j in range(m - 1, 0, -1): dp[i - 1][j - 1] = dp[i][j - 1] + dp[i - 1][j] return dp[0][0]","link":"/6bb5eafc/"},{"title":"Daily LeetCode 63. Unique Paths II","text":"https://leetcode.com/problems/unique-paths-ii/ Medium 问题描述：A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: 123456789101112Input:[ [0,0,0], [0,1,0], [0,0,0]]Output: 2Explanation:There is one obstacle in the middle of the 3x3 grid above.There are two ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down -&gt; Down2. Down -&gt; Down -&gt; Right -&gt; Right 思路及代码：这一题是昨天机器人走路问题的进阶版本，与Unique Paths的区别在，这一题设置了障碍方格，我们只需要在昨天的代码的基础上，对障碍方格进行处理，将障碍方格对应的dp[i][j]设置为0即可。 我还对昨天的代码进行了一部分修改，以适应单行或者单列方格的情况。 1234567891011121314151617181920class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: if len(obstacleGrid) == 1 and len(obstacleGrid[0]) == 1: if obstacleGrid[0][0] == 1: return 0 else: return 1 row = len(obstacleGrid) + 1 column = len(obstacleGrid[0]) + 1 dp = [[0] * column for _ in range(row)] for i in range(row - 1, 0, -1): for j in range(column - 1, 0, -1): if obstacleGrid[row - 2][column - 2] == 0: dp[row - 2][column - 2] = 1 if obstacleGrid[i - 1][j - 1] == 1: dp[i - 1][j - 1] = 0 else: dp[i - 1][j - 1] = dp[i][j - 1] + dp[i - 1][j] return dp[0][0]","link":"/a5a1f2d1/"},{"title":"Daily LeetCode 64. Minimum Path Sum","text":"https://leetcode.com/problems/minimum-path-sum/ Medium 问题描述：Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: 12345678Input:[ [1,3,1], [1,5,1], [4,2,1]]Output: 7Explanation: Because the path 1→3→1→1→1 minimizes the sum. 思路及代码：这一题給定了一个附带权值的grid，左上角为起点，右下角为终点，每次向下或者向右走，要求寻找一条权值之和最小的路径，并返回最小权值和。 我们可以通过一个二维数组dp[i][j]来保存从起点到[i,j]位置的最小权值和，状态转移方程如下： 1dp[i][j] = min(grid[i][j] + dp[i-1][j], grid[i][j] + dp[i][j-1]) 最后我们返回dp[-1][-1]即可。 123456789101112131415161718class Solution: def minPathSum(self, grid: List[List[int]]) -&gt; int: row = len(grid) column = len(grid[0]) dp = [[0] * column for _ in range(row)] print(grid[-1][0]) for i in range(row): for j in range(column): if i == 0 and j == 0: dp[i][j] = grid[i][j] elif i == 0: dp[i][j] = grid[i][j] + dp[i][j - 1] elif j == 0: dp[i][j] = grid[i][j] + dp[i - 1][j] else: dp[i][j] = min(grid[i][j] + dp[i][j - 1], grid[i][j] + dp[i - 1][j]) return dp[row - 1][column - 1] 这一题可以直接在题目给定的grid上修改，从而降低空间复杂度，同时，对第一列和第一行单独处理： 1234567891011def minPathSum(self, grid): m = len(grid) n = len(grid[0]) for i in range(1, n): grid[0][i] += grid[0][i - 1] for i in range(1, m): grid[i][0] += grid[i - 1][0] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) return grid[-1][-1]","link":"/9d508083/"},{"title":"Daily LeetCode 120. Triangle","text":"前几天Mac的键盘再次连击了，今天刚修好，接着来刷算法题。 https://leetcode.com/problems/triangle/ Medium 问题描述：Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 思路及代码：给定一个“金字塔”数组，我们需要找到一条从第一层到最后一层的路径，保证这条路径的权值和是最小的，同时，题目还限定了向下走的方式，每次只能往相邻节点走。 我们可以先从自己解决问题的角度出发，思考解决方法。就拿题目中的例子来说，第一层，选择2；第二层，选择2附近的两个数（3，4）中较小的那个（3）；再从3出发，接着向下选择直到最后一层，最终得到一条权值最小的路径（2-&gt;3-&gt;5-&gt;1）。 为了方便代码的编写，我们选择从底向上的方式： 1234567891011class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: if len(triangle) == 1: return triangle[0][0] for i in range(len(triangle) - 2, -1, -1): for j in range(len(triangle[i])): triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]) return triangle[0][0]","link":"/32429421/"},{"title":"Daily LeetCode 121. Best Time to Buy and Sell Stock","text":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ Easy 问题描述：Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: 1234Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: 123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. 思路及代码：题目给定了一只股票的价格变化情况，我们只能够做一次买进卖出操作，要求最大利润。 我们只需要找出最低的买入价格以及最高的卖出价格，同时要注意，卖出只能在买进之后，我们只需要在一次遍历中更新最低价格和最大利润即可。 123456789101112import sysclass Solution: def maxProfit(self, prices: List[int]) -&gt; int: min_price, max_profit = sys.maxsize, 0 for price in prices: min_price = min(price, min_price) current_profit = price - min_price max_profit = max(current_profit, max_profit) return max_profit","link":"/5f573d82/"},{"title":"Daily LeetCode 139. Word Break","text":"https://leetcode.com/problems/word-break/ Medium 问题描述：Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: 123Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]Output: trueExplanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. Example 2: 1234Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]Output: trueExplanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;. Note that you are allowed to reuse a dictionary word. Example 3: 12Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output: false 思路及代码：这一题是要看给定的字符串经过拆分，是否能够完全匹配字典中的词汇，即s由wordDict中的词构成。我们通过一个二重循环，模拟划分的过程。初始化一个dp数组，将dp[0]设置为1，在遍历过程中更新dp数组。dp[i]等于1的条件有两个：一是dp[j]等于1，表示s[0:j]已经成功划分；二是s[j:i]属于wordDict，表示s[j:i]可以成功划分。最终，我们只需要看dp数组的最后一位是否为1即可。 1234567891011class Solution: def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool: dp = [0] * (len(s) + 1) dp[0] = 1 for i in range(len(s) + 1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = 1 break return dp[-1] == 1","link":"/cfdc9c90/"},{"title":"Daily LeetCode 140. Word Break II","text":"https://leetcode.com/problems/word-break-ii/ Hard 问题描述：Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: 12345678Input:s = &quot;catsanddog&quot;wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]Output:[ &quot;cats and dog&quot;, &quot;cat sand dog&quot;] Example 2: 12345678910Input:s = &quot;pineapplepenapple&quot;wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]Output:[ &quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot;]Explanation: Note that you are allowed to reuse a dictionary word. Example 3: 12345Input:s = &quot;catsandog&quot;wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output:[] 思路及代码：这是昨天那题的进阶版本，昨天的题目只是让我们判断是否能够将s正确切分，今天这题不仅需要判断能否正确划分，同时还要拿划分后的单词拼接成句子，并且要求输出所有可能的句子。 对于这一类的构造相关的问题，我们通常需要用递归来实现，同时，我们还需要基于上一题的结果对递归进行剪枝，降低时间复杂度。 我们定义一个helper函数，该函数的输入分别是当前字符串current_s，构造结果res，当前构造的句子path，判断结果dp以及单词词典wordDict；该函数将原字符串划分为两个部分，若前半部分符合划分条件，即前半部分在wordDict中，将前半部分加入到当前path，接着通过递归操作，判断后半部分。 代码如下： 1234567891011121314151617181920212223242526272829class Solution: def wordBreak(self, s: str, wordDict: List[str]) -&gt; List[str]: def wordBreak(s, wordDict): dp = [0] * (len(s) + 1) dp[0] = 1 for i in range(len(s) + 1): for j in range(i): tmp_str = s[j:i] if dp[j] and tmp_str in wordDict: dp[i] = 1 break return dp def helper(current_s, res, path, dp, wordDict): if dp[-1] == 1: if not current_s: res.append(path.strip()) for i in range(1, len(current_s) + 1): if current_s[:i] in wordDict: helper(current_s[i:], res, path + &quot; &quot; + current_s[:i], dp, wordDict) if not s: return [&quot;&quot;] res = [] dp = wordBreak(s, wordDict) helper(s, res, &quot;&quot;, dp, wordDict) return res","link":"/bbdc03c9/"},{"title":"Daily LeetCode 152. Maximum Product Subarray","text":"https://leetcode.com/problems/maximum-product-subarray/ Medium 问题描述：Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: 123Input: [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6. Example 2: 123Input: [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray. 思路及代码：这一题要求连续子串的最大乘积。 一开始我想暴力求解这个问题，也就是将所有的子串乘积算出来，再比较就完事了，然而暴力求解的后果只有一个，就是TLE，显然不可行。 我们可以换个角度想这个问题，想要找到有最大乘积的子串，我们首先考虑对乘积影响最大的因素，乘积和求和不同，如果遇到0或是负数，最大乘积就可能从最大变成最小，而最小乘积反而变成最大。因此，我们需要同时记录当前的最大乘积和最小乘积。 i位置的最大乘积应该由三个因素决定，分别是当前最大乘积current_max[i]、当前最小乘积current_min[i]以及该位置的数nums[i]。 代码如下： 1234567891011121314def maxProduct(nums): if len(nums) == 1: return nums[0] current_max = [0] * len(nums) current_min = [0] * len(nums) res = current_max[0] = current_min[0] = nums[0] for i in range(1, len(nums)): current_max[i] = max(current_max[i - 1] * nums[i], current_min[i - 1] * nums[i], nums[i]) current_min[i] = min(current_min[i - 1] * nums[i], current_max[i - 1] * nums[i], nums[i]) res = max(res, current_max[i]) return res 我们还可以进一步的改进代码，降低空间复杂度。通过考虑当前nums[i]的正负情况，提前交换当前的最大最小乘积： 123456789101112131415def maxProduct(nums): if len(nums) == 1: return nums[0] current_max = current_min = res = nums[0] for i in range(1, len(nums)): if nums[i] &lt; 0: current_max, current_min = current_min, current_max current_max = max(current_max * nums[i], nums[i]) current_min = min(current_min * nums[i], nums[i]) res = max(current_max, res) return res","link":"/b86dc1cd/"},{"title":"Daily LeetCode 198. House Robber","text":"https://leetcode.com/problems/house-robber/ Easy 问题描述：You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: 1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: 1234Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. 思路及代码：假设你是一个劫匪，给定一个list，内容是每一户的财产价值，相邻的房子之间有报警系统，因此只能选择一个洗劫一空，要求算出最大收入。 这是一题很简单的动态规划的问题，我们维护一个一维数组dp，dp[i]表示到第i户时的最大收益。在第i户，我们比较nums[i]+dp[i-2]和dp[i-1]大小，从而决定当前执行抢劫操作，还是跳过这一户。 1234567891011class Solution: def rob(self, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0], dp[1] = nums[0], max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]) return max(dp)","link":"/5b35389f/"},{"title":"Daily LeetCode 213. House Robber II","text":"https://leetcode.com/problems/house-robber-ii/ Medium 问题描述You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: 1234Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2: 1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. 思路及代码这一题是昨天的House Robber的进阶版，昨天的房子排成了一行，今天的房子排成了一圈，触发警报的规则没有变化，因此我们第一个房子和最后一个房子也是相邻的关系，我们只需要在昨天的基础上分别考虑从第一个房子出发和从第二个房子出发两种“抢劫”方式。 我们维护两个数组start_from_first_house和start_from_second_house，需要注意的是，最终比较大小时，考虑start_from_first_house[-2]和start_from_second_house[-1]，因为从一个房子出发不能把最后一个房子算在里面。 代码： 123456789101112131415class Solution: def rob(self, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 if len(nums) &lt; 2: return nums[0] start_from_first_house = [0] * (len(nums) + 1) start_from_second_house = [0] * (len(nums) + 1) start_from_first_house[1] = nums[0] for i in range(2, len(nums) + 1): start_from_first_house[i] = max(start_from_first_house[i - 1], start_from_first_house[i - 2] + nums[i - 1]) start_from_second_house[i] = max(start_from_second_house[i - 1], start_from_second_house[i - 2] + nums[i - 1]) return max(start_from_first_house[-2], start_from_second_house[-1])","link":"/50b36e5/"},{"title":"Daily LeetCode 221. Maximal Square","text":"https://leetcode.com/problems/maximal-square/ Medium 问题描述Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: 12345678Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4 思路及代码：这一题是从一个二维数组中找出由1构成的最大的正方形的面积，可以通过动态规划的方法来解决，维护一个二维数组dp，dp[i][j]表示以当前点为右下角顶点能够构造的正方形最大边长。 dp数组的第一行和第一列与原数组相同，从第二行开始更新，在遍历过程中，首先判断matrix[i][j]是否为0，若为零，则当前点不能作为正方形的右下顶点，dp[i][j]设置为零；接着从dp[i][j]左边dp[i-1][j]、上边dp[i][j-1]以及斜上方dp[i-1][j-1]中选取最小值加一作为dp[i][j]的值。 拿题中例子来说，输入$$1 \\quad 0\\quad 1 \\quad 0\\quad 0\\1 \\quad 0\\quad 1 \\quad 1\\quad 1\\1 \\quad 1\\quad 1 \\quad 1\\quad 1\\1 \\quad 0\\quad 0 \\quad 1\\quad 0$$dp数组为：$$1 \\quad 0\\quad 1 \\quad 0\\quad 0\\1 \\quad 0\\quad 1 \\quad 1\\quad 1\\1 \\quad 1\\quad 1 \\quad 2\\quad 2\\1 \\quad 0\\quad 0 \\quad 1\\quad 0$$代码如下： 1234567891011121314151617181920class Solution: def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if len(matrix) == 0: return 0 dp = [[0] * len(matrix[0]) for _ in range(len(matrix))] res = 0 for i in range(len(matrix[0])): dp[0][i] = int(matrix[0][i]) res = max(res, dp[0][i]) for j in range(len(matrix)): dp[j][0] = int(matrix[j][0]) res = max(res, dp[j][0]) for i in range(1, len(matrix)): for j in range(1, len(matrix[0])): if int(matrix[i][j]): dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1 res = max(dp[i][j], res) return res ** 2","link":"/727207c7/"},{"title":"Daily LeetCode 264. Ugly Number II","text":"https://leetcode.com/problems/ugly-number-ii/ Medium 问题描述Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example: 123Input: n = 10Output: 12Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note: 1 is typically treated as an ugly number. n does not exceed 1690. Hint1 The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones. Hint2 An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number. Hint3 The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: $L_1,L_2,L_3$ Hint4 Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 * 2, L2 * 3, L3 * 5). 思路及代码题目给出了ugly number的定义：质因数仅为2、3、5的数，同时，1也被看作是ugly number，我们需要找出第n个ugly number。 这一题显然不能够用暴力解法一个个找，题目中的提示已经给出了解法，所有的ugly number都应该由一个小的丑陋数序列乘2、3或5得到，因此，丑陋数序列可以拆分为三个子序列： ==1x2==, 2x2, ==2x2==, 3x2, ==3x2==, 4x2, …… 1x3, ==1x3==, 2x3, 2x3, 2x3, ==2x3==, …… 1x5, 1x5, 1x5, ==1x5==, 2x5, 2x5, …… 我们依次在三个子序列中找到当前最小的丑陋数，将其加到res数组中，这样就能够形成一个递增的丑陋数序列。 代码如下： 1234567891011121314class Solution: def nthUglyNumber(self, n: int) -&gt; int: res = [1] index2, index3, index5 = 0, 0, 0 while len(res) &lt; n: multi2, multi3, multi5 = res[index2] * 2, res[index3] * 3, res[index5] * 5 min_multi = min(multi2, multi3, multi5) if min_multi == multi2: index2 += 1 if min_multi == multi3: index3 += 1 if min_multi == multi5: index5 += 1 res.append(min_multi) return res[-1]","link":"/11159586/"},{"title":"Daily LeetCode 300. Longest Increasing Subsequence","text":"https://leetcode.com/problems/longest-increasing-subsequence/ Medium 问题描述Given an unsorted array of integers, find the length of longest increasing subsequence. Example: 123Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note: There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? 思路及代码这一题要求最长升序子串的长度。 我们可以维护一个一维数组dp，dp[i]表示Input[0:i]中最长升序子串的长度，对于每一个Input[0:i-1]，我们在这个子串中寻找是否存在小于Input[i]的数Input[j]，如果找到了，则说明当前Input[i]可以作为Input[j]的升序子串的下一个数，我们就可以更新dp数组：dp[i]=max(dp[j] + 1, dp[i])，最终返回dp数组中的最大值，即最长升序子串的长度。 代码： 12345678910class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 dp = [1] * (len(nums)) for i in range(1, len(nums)): for j in range(i): if nums[j] &lt; nums[i]: dp[i] = max(dp[j] + 1, dp[i]) return max(dp) 下面是从论坛看到的时间复杂度为O(nlogn)的解法： 维护一个tails数组，保存所有升序子串中最小的“尾元素”，长度为i+1的子串的tail保存在tails[i]中。 假设给定数组[4, 5, 6, 3]： 123len = 1 : [4], [5], [6], [3] =&gt; tails[0] = 3len = 2 : [4, 5], [5, 6] =&gt; tails[1] = 5len = 3 : [4, 5, 6] =&gt; tails[2] = 6 我们可以看出，tails数组肯定是一个升序数组，因此我们可以二分查找tails数组，找出需要更新的项： 12(1) if x is larger than all tails, append it, increase the size by 1(2) if tails[i-1] &lt; x &lt;= tails[i], update tails[i] 代码如下： 1234567891011121314def lengthOfLIS(self, nums): tails = [0] * len(nums) size = 0 for x in nums: i, j = 0, size while i != j: m = (i + j) / 2 if tails[m] &lt; x: i = m + 1 else: j = m tails[i] = x size = max(i + 1, size) return size","link":"/c1a3efe2/"},{"title":"Daily LeetCode 309. Best Time to Buy and Sell Stock with Cooldown","text":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ Medium 问题描述Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: 123Input: [1,2,3,0,2]Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] 思路及代码这又是一道与股票相关的问题，与之前的买入卖出不同，这一题引入了cooldown概念，每当执行一次卖出操作后，第二天必须cooldown一天，不能够进行买入操作。在这样一个操作规则下，我们需要求出最大的利润。 我们可以用一个自动机来表示这个问题的三个状态： 三个状态的更新过程如下： 123456#保持s0状态，或者从cooldown状态出来s0[i] = max(s0[i - 1], s2[i - 1]);#保持s1状态，或者执行购入操作s1[i] = max(s1[i - 1], s0[i - 1] - prices[i]);#只有一个操作，s1-&gt;s2s2[i] = s1[i - 1] + prices[i]; 代码如下： 123456789def maxProfit(prices): s0, s1, s2 = [0] * len(prices), [0] * len(prices), [0] * len(prices) s0[0], s1[0], s2[0] = 0, -prices[0], -sys.maxsize for i in range(1, len(prices)): s0[i] = max(s0[i - 1], s2[i - 1]) s1[i] = max(s1[i - 1], s0[i - 1] - prices[i]) s2[i] = s1[i - 1] + prices[i] return max(s0[-1], s2[-1]) 由于每一时刻状态只和前一个时刻有关，我们可以将空间复杂度减少到O(1): 1234567891011class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if len(prices) == 0: return 0 buy, wait_for_sell, cooldown = 0, -prices[0], -sys.maxsize for i in range(1, len(prices)): pre_state_sell = wait_for_sell wait_for_sell = max(wait_for_sell, buy - prices[i]) buy = max(buy, cooldown) cooldown = pre_state_sell + prices[i] return max(cooldown, buy)","link":"/836f6af0/"},{"title":"Daily LeetCode 343. Integer Break","text":"https://leetcode.com/problems/integer-break/ Medium 问题描述Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. Example 1: 123Input: 2Output: 1Explanation: 2 = 1 + 1, 1 × 1 = 1. Example 2: 123Input: 10Output: 36Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. Note: You may assume that n is not less than 2 and not larger than 58. 思路及代码：这是一条拆分数字的题目，要求把一个正数拆分为至少两个正数的和，保证拆分后的乘积最大。既然是拆分，那么肯定会用到更小的数拆分的结果，维护一个数组dp，dp[i]保存着拆分i后的最大乘积。 对于给定数字n，我们从3开始遍历，每一次遍历i，都考虑所有拆分i的情况，即考虑j*(i-j), j区间[1, i-1]，更新dp[i]，dp[i]=max(dp[i],j*(i-j),dp[i-j]*j) 代码如下： 12345678class Solution: def integerBreak(self, n: int) -&gt; int: dp = [1] * (n + 1) for i in range(3, n + 1): for j in range(i): dp[i] = max(dp[i], max(j * (i - j), dp[i - j] * j)) return dp[-1]","link":"/63ae83a/"},{"title":"Daily LeetCode 279. Perfect Squares","text":"上周有三门考试，刷题就停了一周，今天继续。 https://leetcode.com/problems/perfect-squares/ Medium 问题描述Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: 123Input: n = 12Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: 123Input: n = 13Output: 2Explanation: 13 = 4 + 9. 思路及代码这一题要求一个数最少能拆分成几个完全平方数的和。 因为实在动态规划的问题列表里面刷的题，所以我就直接从动态规划入手解决这个问题了。维护一个长度为n+1的一维数组dp，dp[i]表示i最少能拆分成几个完全平方数的和，dp[0]初始化为0，其余位置初始化为sys.maxsize。用一个二重循环更新dp数组，dp[i + j * j] = min(dp[i + j * j], dp[i] + 1)，dp[n]即为我们要求的结果。 代码如下： 123456789101112import sysclass Solution: def numSquares(self, n: int) -&gt; int: dp = [sys.maxsize] * (n + 1) dp[0] = 0 for i in range(n+1): j = 1 while i + j * j &lt;= n: dp[i + j * j] = min(dp[i + j * j], dp[i] + 1) j += 1 return dp[-1] 但是这种方法的时间复杂度很高，我在LeetCode的论坛看到了其它一些更好的方法： 数学方法 首先，我们需要了解四平方和定理，每个正整数都能够表示成四个整数的平方和，因此返回值只有可能有四种：1，2，3，4 当n是完全平方数时，返回值为1 当n能够写成$n=4^k\\times (8 \\times m +7)$的形式时，返回值为4 12345678910111213141516171819202122import mathclass Solution: def numSquares(self, n: int) -&gt; int: def is_square(n): sqrt_n = int(math.sqrt(n)) return sqrt_n ** 2 == n if is_square(n): return 1 while n &amp; 3 == 0: #n%4==0 n &gt;&gt;= 2 if n &amp; 7 == 7: #n%8 == 7 return 4 sqrt_n = int(math.sqrt(n)) for i in range(1, sqrt_n + 1): if is_square(n - i * i): return 2 return 3 BFS 广度优先遍历的思想是将小于等于n的每个完全平方数都看作是图中的一个节点，当且仅当满足j = i + 完全平方数时，i节点与j节点相连。从0节点开始做广度优先遍历，当遍历到节点n时，说明我们遍历过的节点和为n，此时遍历步数就是最终结果。 大佬的代码如下： 123456789101112class Solution: def numSquares(self, n: int) -&gt; int: if n &lt;= 0: return 0 perfect_squres = [i ** 2 for i in range(1, int(n ** 0.5) + 1)] d, q, nq = 1, {n}, set() while q: for node in q: for square in perfect_squres: if node == square: return d if node &lt; square: break nq.add(node - square) d, q, nq = d + 1, nq, set()","link":"/778283b7/"},{"title":"Daily LeetCode 368. Largest Divisible Subset","text":"https://leetcode.com/problems/largest-divisible-subset/ Medium 问题描述Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1: 12Input: [1,2,3]Output: [1,2] (of course, [1,3] will also be ok) Example 2: 12Input: [1,2,4,8]Output: [1,2,4,8] 思路及代码这一题有点类似于求最长升序子串，需要从一系列数字中找出最长的子串，要求这个子串中每一对数字都是能够整除的，即一个数为另一个数的约数。 既然与LIS类似，就可以用动态规划来解题，维护一个一维数组dp，dp[i]保存的是一个列表，表示从0~i位置满足题目要求的最长子串。 通过一个二重循环更新dp数组，先将题目给定数组从小到大排序，i从0向后遍历，j从i位置向前遍历，第二重遍历的目的是寻找能够被nums[i]整除的nums[j]，同时比较dp[i]和dp[j]对应的子串的大小，因为我们要找最长子串，因此只在len(dp[j])&gt;max_size的情况下才对其进行更新。 123456789101112131415161718192021222324class Solution: def largestDivisibleSubset(self, nums: List[int]) -&gt; List[int]: if len(nums) == 0: return [] dp = [[] for _ in range(len(nums))] max_index, max_size = 0, -1 final_index, final_size = 0, -1 nums.sort() for i in range(len(nums)): for j in range(i, -1, -1): if nums[i] % nums[j] == 0 and len(dp[j]) &gt; max_size: max_index = j max_size = len(dp[j]) if max_size != -1: dp[i] += dp[max_index] dp[i].append(nums[i]) if len(dp[i]) &gt; final_size: final_size = len(dp[i]) final_index = i max_index, max_size = 0, -1 return dp[final_index]","link":"/6bbb627a/"},{"title":"Daily LeetCode 377. Combination Sum IV","text":"https://leetcode.com/problems/combination-sum-iv/ Medium 问题描述：Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: 123456789101112131415nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. Follow up:What if negative numbers are allowed in the given array?How does it change the problem?What limitation we need to add to the question to allow negative numbers? 思路及代码：给定一个nums数组和target，我们从nums中选数，找出所有组合，使得组合的和为target，最后返回组合个数。需要注意的是，不同排列顺序的组合被看作是不同的组合，需要重复计数。 我们可以反着思考这个问题，假设我们只需要再找一个数就能够使得和为target，我们从nums数组中找任何一个小于target的数即可。维护一维数组dp，dp[i]表示当target为i时，能够找到的组合数，dp[target] = sum(dp[target - nums[i]]), 0 &lt;= i &lt; len(nums), target &gt;= nums[i]。由于0只能够由0得到，因此dp[0]=1。在题目中给的例子中，dp[4] = dp[3] + dp[2] + dp[1]。 代码： 12345678910class Solution: def combinationSum4(self, nums: List[int], target: int) -&gt; int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in range(len(nums)): if i &gt;= nums[j]: dp[i] += dp[i - nums[j]] return dp[target] 给定数组中存在负数的情况： 当给定数组中存在负数时，组合数将是无穷无尽的。 例如，给定[1, -1, 2, -2]，target为0时，我们能够找出无穷多个组合，来满足和为0这一条件。","link":"/1e1fa69f/"},{"title":"Daily LeetCode 416. Partition Equal Subset Sum","text":"https://leetcode.com/problems/partition-equal-subset-sum/ Medium 问题描述：Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: 12345Input: [1, 5, 11, 5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: 12345Input: [1, 2, 3, 5]Output: falseExplanation: The array cannot be partitioned into equal sum subsets. 思路及代码：给定一个只含有正数的数组，我们要判断该数组是否能够拆分成两部分，保证两部分的和相等。 既然是两部分的和相等，那么目标和一定是整个数组的和除2，我们先求整个数组的和，判断除2后是否为整数，若不是整数，那么直接返回False。 和除2为整数时，此时问题就转化为，我们需要将数组切分为两个和均为sum/2的部分，维护一维数组dp，dp[i]表示原数组是否能够取出若干数字，使得这些数字的和为i。找出数字的和为sum/2，也保证剩下的部分和也为sum/2。 有了dp数组，我们就要确定状态转移方程，dp[i]能否为True，与dp[i-当前取出数字]是否为True相关。 12345678910111213141516171819class Solution: def canPartition(self, nums: List[int]) -&gt; bool: sum = 0 for num in nums: sum += num if sum % 2 == 0: sum = int(sum / 2) else: return False dp = [False] * (sum + 1) dp[0] = True for num in nums: for i in range(sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[sum]","link":"/7c739f8c/"},{"title":"Daily LeetCode 1. Two Sum","text":"https://leetcode.com/problems/two-sum/ Easy 今天开始刷一波LeetCode上的Top 100 Liked Questions 问题描述Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路及代码：暴力解法： 感觉一般easy难度的题目都能用暴力求解，用一个二重循环，对list进行两次遍历，判断当前元素与后来某一个元素和是否为target 代码： 123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for index, num in enumerate(nums): for j in range(index + 1, len(nums)): if nums[j] == target - num: return [index, j] 字典： 通过字典在遍历过程中保存[num, index]对，在后续的遍历中，检查target-num是否存在于字典中，若存在，即这两个元素和为target，返回两个index即可，若不存在，则将当前元素以及index加入到字典中。 123456789class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dict = {} for index, num in enumerate(nums): tmp = target - num if tmp in dict: return [dict[tmp], index] else: dict[num] = index","link":"/d993d484/"},{"title":"Daily LeetCode 11. Container With Most Water","text":"https://leetcode.com/problems/container-with-most-water/ Medium 问题描述：Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: 12Input: [1,8,6,2,5,4,8,3,7]Output: 49 思路及代码：这一题其实跟水啥的都没关系，就是要求一个最大的矩形区域，给定的数组中的值是矩形的宽，元素之间的距离是矩形的长。 这一题用双指针可以很容易的解决，分别从最左和最右开始，计算当前情况下区域的面积，挑选左右两个指针中较小的那个，向中间移动。在每一次移动中同时更新当前的最大面积。 代码： 1234567891011class Solution: def maxArea(self, height: List[int]) -&gt; int: left_index, right_index, width, res = 0, len(height) - 1, len(height) - 1, 0 for index in range(width, 0, -1): if height[left_index] &lt; height[right_index]: res = max(res, index * height[left_index]) left_index += 1 else: res = max(res, index * height[right_index]) right_index -= 1 return res","link":"/1e9553ba/"},{"title":"Daily LeetCode 15. 3Sum","text":"https://leetcode.com/problems/3sum/ Medium 问题描述Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 思路及代码这一题要求从一个数组中找三个数，确保三个数的和为零，返回所有的和为零的三个数组成的数组。 首先，我们对数组进行排序，对升序数组进行遍历，在遍历过程中，我们使用双指针寻找另外两个数。 如果当前遍历到的数大于零，我们可以结束遍历，因为此时数组是升序的，三个正数的和不可能为零；如果当前遍历到的数与前一个数相等，那么就跳过这个数，因为结果需要删除重复结果。 假设当前遍历到了nums[i]，我们设置左指针left_index=i+1, right_index=len(nums)-1，当前sum = nums[i] + nums[left_index] + nums[right_index]，此时根据sum的情况进行下一步操作： sum&gt;0：说明当前取的正数偏大，将右指针左移 sum&lt;0：说明当前取的负数偏小，将左指针右移 sum=0：将当前三个数加入结果，并且将左右指针移到没有重复元素的位置 代码： 1234567891011121314151617181920212223class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() res = [] for i in range(len(nums) - 2): if nums[i] &gt; 0: break if i &gt; 0 and nums[i] == nums[i - 1]: continue left_index, right_index = i + 1, len(nums) - 1 while left_index &lt; right_index: sum = nums[i] + nums[left_index] + nums[right_index] if sum &gt; 0: right_index -= 1 elif sum &lt; 0: left_index += 1 else: res.append([nums[i], nums[left_index], nums[right_index]]) while left_index &lt; right_index and nums[left_index + 1] == nums[left_index]: left_index += 1 while left_index &lt; right_index and nums[right_index - 1] == nums[right_index]: right_index -= 1 left_index += 1 right_index -= 1 return res","link":"/58cc1b58/"},{"title":"Daily LeetCode 17. Letter Combinations of a Phone Number","text":"https://leetcode.com/problems/letter-combinations-of-a-phone-number/ Medium 问题描述Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: 12Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 思路及代码九宫格键盘每个数字都对应着一些字母，给一个数字串，求出所有数字对应的字母之间的组合。 首先我们建立一个字典保存每个数字对应的字母，初始化res数组为''，遍历字符串digits 在遍历过程中，保存当前数字对应的字母串，初始化数组保存当前的字母组合结果，用一个二重循环来生成当前的字母组合。 代码如下： 123456789101112131415161718192021222324class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: dict = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } res = [''] if digits else [] for digit in digits: current_string = dict[digit] current_res = [] for comb in res: for letter in current_string: current_res.append(comb + letter) res = current_res return res 这个问题还可以用递归来解 123456789101112131415def letterCombinations(self, digits): if not digits: return [] dic = {&quot;2&quot;:&quot;abc&quot;, &quot;3&quot;:&quot;def&quot;, &quot;4&quot;:&quot;ghi&quot;, &quot;5&quot;:&quot;jkl&quot;, &quot;6&quot;:&quot;mno&quot;, &quot;7&quot;:&quot;pqrs&quot;, &quot;8&quot;:&quot;tuv&quot;, &quot;9&quot;:&quot;wxyz&quot;} res = [] self.dfs(digits, dic, 0, &quot;&quot;, res) return res def dfs(self, digits, dic, index, path, res): if len(path) == len(digits): res.append(path) return for i in range(index, len(digits)): for j in dic[digits[i]]: self.dfs(digits, dic, i+1, path+j, res)","link":"/ced9d002/"},{"title":"Daily LeetCode 19. Remove Nth Node From End of List","text":"https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Medium 问题描述Given a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? 思路及代码这一题要删除链表的倒数第n个元素，我们可以先将链表反转，然后转化为删除第n个节点的问题，最后返回再次反转的链表即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: def reverseList(head): if head is None or head.next is None: return head; pre = None; cur = head; h = head; while cur: h = cur; tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; return h length = 0 tmp = head while tmp: length += 1 tmp = tmp.next if n == 1: return reverseList(reverseList(head).next) if length == n: return head.next head = reverseList(head) count = 1 tmp = head while count != n - 1: count += 1 tmp = tmp.next tmp.next = tmp.next.next return reverseList(head) 题目中的进阶要求是，在一次遍历过程中解决这个问题，我们可以设置两个指针，先让前指针走n步，走n步后，后指针也开始走，当前指针走到链表表尾时，后指针恰好走到要删除的元素的位置，这样就能够在一次遍历过程中得到结果。 代码如下： 123456789101112131415161718192021222324252627282930313233def removeNthFromEnd(head, n): &quot;&quot;&quot; :type head: ListNode :type n: int :rtype: ListNode &quot;&quot;&quot; #前后指针 frontNode = head behindNode = head length = 0 #前指针先走n步 for i in range(n): frontNode = frontNode.next length += 1 print &quot;length = &quot;,length print &quot;n = &quot;,n #代表要删除的是第一个元素 if frontNode == None: return head.next #前后指针同时走 while (frontNode.next): frontNode = frontNode.next behindNode = behindNode.next length += 1 print &quot;length = &quot;,length #删除元素 behindNode.next = behindNode.next.next return head","link":"/9dbce41f/"},{"title":"Daily Leetcode 892. Surface Area of 3D Shapes","text":"https://leetcode.com/problems/surface-area-of-3d-shapes/ 问题描述：On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes. Example 1: 12Input: [[2]]Output: 10 Example 2: 12Input: [[1,2],[3,4]]Output: 34 Example 3: 12Input: [[1,0],[0,2]]Output: 16 Example 4: 12Input: [[1,1,1],[1,0,1],[1,1,1]]Output: 32 Example 5: 12Input: [[2,2,2],[2,1,2],[2,2,2]]Output: 46 题目分析：这一题的输入是一个二维数组grid，grid[i][j]的值表示[i][j]位置上的方块个数，所有的方块摆放在一起构成一个立方体，我们需要做的，就是计算这个立方体的面积。 由x个方块构成的柱体的表面积大小为x*4+2，我们将每一个位置柱体的表面积单独计算相加，得到未考虑重叠部分的面积总和S再考虑重叠部分。重叠部分的处理也很简单，从[0][0]位置开始遍历，计算当前柱体与下边和右边柱体重叠部分大小a，由于在计算表面积总和时，重叠部分计算了两次，因此我们需要从S中减去a*2。 代码：1234567891011121314151617class Solution(object): def surfaceArea(self, grid): &quot;&quot;&quot; :type grid: List[List[int]] :rtype: int &quot;&quot;&quot; N, res = len(grid), 0 for i in range(N): for j in range(N): if grid[i][j]: res = res + grid[i][j]*4 + 2 if i &lt; N - 1: res = res - min(grid[i+1][j], grid[i][j])*2 if j &lt; N - 1: res = res - min(grid[i][j+1], grid[i][j])*2 return res","link":"/76405f54/"},{"title":"Daily Leetcode 242. Valid Anagram","text":"https://leetcode.com/problems/valid-anagram/ 问题描述：Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: 12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true Example 2: 12Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false 题目分析：输入两个字符串s和t，判断两个字符串是不是重排的，我们只需要判断两点，一是两个字符串的长度是否相同，二是组成两个字符串的各个字符数量是否相同。 我们可以初始化一个长度为26的数组，该数组的值均为0，遍历s，得到对应字符数量；再遍历t，减去对应字符数量。最后判断数组是否有非零元素，如果有，则不是重排。 代码：123456789101112131415161718class Solution(object): def isAnagram(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: bool &quot;&quot;&quot; if len(s) != len(t): return False tmp = [0] * 26 for ch in s: tmp[ord(ch) - ord('a')] +=1 for ch in t: tmp[ord(ch) - ord('a')] -= 1 return all(count == 0 for count in tmp)","link":"/4f8a2c6a/"},{"title":"Daily Leetcode 234. Palindrome Linked List","text":"https://leetcode.com/problems/palindrome-linked-list/ 问题描述：Given a singly linked list, determine if it is a palindrome. Example 1: 12Input: 1-&gt;2Output: false Example 2: 12Input: 1-&gt;2-&gt;2-&gt;1Output: true Follow up:Could you do it in O(n) time and O(1) space? 题目分析：这题难度不大，给定一个单链表，我们需要判断它是不是回文串。 将链表的前半部分存在栈中，利用栈先入后出的特性，将链表后半部分元素值与栈中元素值一一对比，全部相同则说明是回文串，反之，则不是。 代码：1234567891011121314151617181920212223242526272829303132333435class Solution(object): def isPalindrome(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if not head or not head.next: return True length = 0 tmp, half = head, head stack = [] while tmp: length+=1 tmp = tmp.next halfLength = length / 2 for i in range(halfLength): stack.append(half.val) half = half.next if length % 2 != 0: half = half.next while half: current = stack[halfLength - 1] if half.val != current: return False half = half.next halfLength-=1 return True Follow up这一题的Follow up是要求我们能够在O(n)时间复杂度、以及O(1)空间复杂度的条件下解决这个问题，我的代码并没有达到题目要求，在讨论区，我看到了更好的解法： 思路1采用快慢指针 思路2翻转前半部分或后半部分链表，与其余部分进行比较 123456789101112def isPalindrome(self, head): rev = None slow = fast = head while fast and fast.next: fast = fast.next.next rev, rev.next, slow = slow, rev, slow.next if fast: slow = slow.next while rev and rev.val == slow.val: slow = slow.next rev = rev.next return not rev","link":"/46426871/"},{"title":"Daily Leetcode 120. Triangle","text":"https://leetcode.com/problems/triangle/ 问题描述：Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 题目分析：这一题乍一看，不注意约束条件，会觉得是一条easy难度的题目，就觉得是在等腰三角形中从上至下找一条最短和路径，然而题目中加上了约束条件：只能往下或者往右下移动。我们可以利用动态规划解决这种存在约束条件的路径求解问题。 从(i,j)位置向下走得到的最短路径长度： mp(i,j)=min{mp(i+1,j), mp(i+1,j+1)}+triangle(i,j) 我们可以从等腰三角形的底层向上一步步推，这样到最顶层就能够得到最短和路径，以原题所给示例为例子： 12345678910111213mp(3,0) = 4mp(3,1) = 1mp(3,2) = 8mp(3,3) = 3mp(2,0) = min{mp(3,0), mp(3,1)} + triangle(2,0) = 7mp(2,1) = min{mp(3,1), mp(3,2)} + triangle(2,1) = 6mp(2,2) = min{mp(3,2), mp(3,3)} + triangle(2,2) = 10mp(1,0) = min{mp(2,0), mp(2,1)} + triangle(1,0) = 9mp(1,1) = min{mp(2,1), mp(2,2)} + triangle(1,1) = 10mp(0,0) = min{mp(1,0), mp(1,1)} + triangle(0,0) = 11 由上述推导，我们可以得出在这个例子中，最短和路径应该是2+3+5+1 = 11 代码：1234567891011121314151617def minimumTotal(self, triangle): &quot;&quot;&quot; :type triangle: List[List[int]] :rtype: int &quot;&quot;&quot; length = len(triangle) if length == 0: return 0 if length == 1: return triangle[0][0] mp = [[0]*length for i in range(length)] mp[length - 1] = triangle[length - 1] for i in range(length - 2, -1 , -1): for j in range(len(triangle[i])): mp[i][j] = min(mp[i + 1][j], mp[i + 1][j + 1]) + triangle[i][j] return mp[0][0]","link":"/6f042c11/"},{"title":"Daily Leetcode 670. Maximum Swap","text":"https://leetcode.com/problems/maximum-swap/ 问题描述：Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get. Example 1: 123Input: 2736Output: 7236Explanation: Swap the number 2 and the number 7. Example 2: 123Input: 9973Output: 9973Explanation: No swap. Note: The given number is in the range [0, 108] 题目分析：这一题的目的是通过交换给定数字中的任意两个数，使得交换后的数最大。 我们将最右最大的数（数位较低）与最左最小的数（数位较高）交换，就能够保证得到一个最大的数。我们首先将最后一位数记为最右最大数，位置记为currentMaxPos，再从右向左遍历，若i位置上的数小于currentMaxPos，则当前交换对为(i, currentMaxPos)；若i位置上的数大于currentMaxPos，则currentMaxPos更新为i。遍历完成后，将位置i上的数与位置currentMaxPos上的数进行交换即可。 代码：1234567891011121314151617181920class Solution(object): def maximumSwap(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; tmpNum = list(str(num)) currentMaxPos = len(tmpNum) - 1 leftMin, rightMax = 0, 0 for i in reversed(range(len(tmpNum))): if tmpNum[i] &lt; tmpNum[currentMaxPos]: leftMin, rightMax = i, currentMaxPos elif tmpNum[i] &gt; tmpNum[currentMaxPos]: currentMaxPos = i tmpNum[leftMin], tmpNum[rightMax] = tmpNum[rightMax], tmpNum[leftMin] return int(&quot;&quot;.join(tmpNum))","link":"/4f690e40/"},{"title":"Daily Leetcode 826. Most Profit Assigning Work","text":"https://leetcode.com/problems/most-profit-assigning-work/ Medium 问题描述：We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job. Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i]. Every worker can be assigned at most one job, but one job can be completed multiple times. For example, if 3 people attempt the same job that pays 1,thenthetotalprofitwillbe1,thenthetotalprofitwillbe3. If a worker cannot complete any job, his profit is $0. What is the most profit we can make? Example 1: 123Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]Output: 100 Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately. Notes: 1 &lt;= difficulty.length = profit.length &lt;= 10000 1 &lt;= worker.length &lt;= 10000 difficulty[i], profit[i], worker[i] are in range [1, 10^5] 题目分析：题目给了三个数组，分别是difficulty, profit, worker，difficulty[i]表示ith任务的难度，profit[i]表示ith任务的报酬，而worker[i]表示ith员工的工作能力，当工作能力大于工作难度时，才能够胜任该任务。我们需要规划工作方案，得到最大的利润值。 这一题显然可以使用贪心策略，由于工作难度与报酬是一一对应的，我们可以使用zip方法将它们组合成一个二维list，并且按工作难度升序排序；再对工人按工作能力进行升序排序。得到job数组和排过序的worker数组，这样，我们只需要遍历一次worker数组，为每一个工人选择它能力范围内最高报酬的工作，就能够得到当前情况下的最大利润值。 代码：123456789101112131415161718class Solution(object): def maxProfitAssignment(self, difficulty, profit, worker): &quot;&quot;&quot; :type difficulty: List[int] :type profit: List[int] :type worker: List[int] :rtype: int &quot;&quot;&quot; res = i = currentBest = 0 job = sorted(zip(difficulty, profit), key = lambda t: t[0]) for ability in sorted(worker): while i &lt; len(job) and ability &gt;= job[i][0]: currentBest = max(currentBest, job[i][1]) i += 1 res += currentBest return res","link":"/b53378e2/"},{"title":"Daily Leetcode 695. Max Area of Island","text":"https://leetcode.com/problems/max-area-of-island/ Medium 问题描述：Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1‘s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: 12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally. Example 2: 1[[0,0,0,0,0,0,0,0]] Given the above grid, return 0. Note: The length of each dimension in the given grid does not exceed 50. 题目分析：给定一个由0、1组成的二维数组，1代表陆地，0代表水域，上下左右相邻的1可以视作是同一个岛屿，我们需要输出整个数组中面积最大的“岛屿”。 这一题可以通过深度优先遍历来寻找面积最大的岛， 在递归时，我们只需要考虑上下左右四种情况即可，需要注意的是，在遍历一个点后，我们需要将其置为0，以防止重复计算面积。 代码：12345678910111213141516171819202122class Solution(object): def maxAreaOfIsland(self, grid): &quot;&quot;&quot; :type grid: List[List[int]] :rtype: int &quot;&quot;&quot; def dfs(i, j, grid): if i &gt;= 0 and i &lt; len(grid) and j &gt;= 0 and j &lt; len(grid[0]) and grid[i][j]: grid[i][j] = 0 return 1 + dfs(i - 1, j, grid) + dfs(i + 1, j, grid) + dfs(i, j - 1, grid) + dfs(i, j + 1, grid) return 0 res = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j]: res = max(dfs(i, j, grid), res) return res","link":"/71655a32/"},{"title":"Daily Leetcode 513. Find Bottom Left Tree Value","text":"https://leetcode.com/problems/find-bottom-left-tree-value/ Medium 问题描述：Given a binary tree, find the leftmost value in the last row of the tree. Example 1: 12345678Input: 2 / \\ 1 3Output:1 Example 2: 123456789101112Input: 1 / \\ 2 3 / / \\ 4 5 6 / 7Output:7 Note: You may assume the tree (i.e., the given root node) is not NULL. 题目分析：所谓leftmost，就是要找到给定二叉树最深层次、位置在最左边的那个节点，二叉树相关的问题基本上都可以转换成树的遍历的问题。我们可以以先序顺序遍历给定二叉树，在遍历过程中，更新最大深度和对应的最大值，只有当前节点的深度大于遍历至今保存的最大深度时，才进行上述更新操作。 代码：123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def findBottomLeftValue(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.currentMaxVal = root.val self.currentMaxDepth = 0 def helper(root, depth): if not root: return 0 if depth &gt; self.currentMaxDepth: self.currentMaxVal = root.val self.currentMaxDepth = depth if root.left: helper(root.left, depth + 1) if root.right: helper(root.right, depth + 1) helper(root, 1) return self.currentMaxVal","link":"/8c43ef88/"},{"title":"Daily Leetcode 687. Longest Univalue Path","text":"https://leetcode.com/problems/longest-univalue-path/ 问题描述：Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. The length of path between two nodes is represented by the number of edges between them. Example 1: Input: 12345 5 / \\ 4 5 / \\ \\1 1 5 Output: 2 Example 2: Input: 12345 1 / \\ 4 5 / \\ \\4 4 5 Output: 2 Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. 题目分析：这一题给的输入是一个二叉树，我们要求该二叉树中最长的相同值路径。很多与树相关的问题都可以通过递归来解决，这个问题也是如此：我们分别求左右子树中的最长相同路径长度，返回左右子树中较长的路径长度值，再判断当前结点与左右子结点的关系；若当前结点的值与左右子节点的值相同，则最长路径值+1。并且，在每一次递归时都更新当前的最大路径长度。 代码：12345678910111213141516171819class Solution(object): def longestUnivaluePath(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.res = 0 def traversePath(root, rootValue): if not root: return 0; left, right = traversePath(root.left, root.val), traversePath(root.right, root.val) self.res = max(self.res, left + right) return 1 + max(left, right) if root.val == rootValue else 0 traversePath(root, None) return self.res","link":"/6f2da4a2/"},{"title":"Daily LeetCode 797. All Paths From Source to Target","text":"https://leetcode.com/problems/all-paths-from-source-to-target/ Medium 问题描述：Given a directed, acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order. The graph is given as follows: the nodes are 0, 1, …, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists. 123456789Example:Input: [[1,2], [3], [3], []] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this:0---&gt;1| |v v2---&gt;3There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3. Note: The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path. 题目分析：这一题给定了有向无环图graph，要求找出所有起点到终点的路径。 这一题图的表示方法有点奇怪，给定二维数组graph，graph[i]的内容表示结点i指向哪些结点，例如题中例子：graph[0]=[1, 2]表明结点0分别有指向1， 2两个结点的路径。 我们直接套用经典的dfs模板就能够解决这一题，遍历停止的条件是当前位置等于终点。 代码：1234567891011121314151617181920class Solution(object): def allPathsSourceTarget(self, graph): &quot;&quot;&quot; :type graph: List[List[int]] :rtype: List[List[int]] &quot;&quot;&quot; def dfs(graph, res, position, path): if position == len(graph) - 1: res.append(path) return else: for n in graph[position]: dfs(graph, res, n, path + [n]) res = [] dfs(graph, res, 0, [0]) return res","link":"/ad1cac84/"},{"title":"Daily Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee","text":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ Medium 问题描述：Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: 1234Input: prices = [1, 3, 2, 8, 4, 9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. Note: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 题目分析：给定数组prices，第i-th元素表示在第i天的股票价格，每一手股票，需要收取的手续费为fee，同时最多持有一只股票，我们需要寻找最好的买入卖出策略，从而得到最大利润。 这一题同样可以使用动态规划思想来解决，我们需要两个状态，一个是买状态，一个是卖状态。买状态其实保存的是当前最小的购买花费，卖状态保存的是直到目前最大的收益。买入卖出操作均有前一天的买卖状态决定，当收益“为大”，就执行卖出操作。 以题目所给示例为例： 12345678910111213141516buy[0] = -fee - prices[0] = -3 #第一天买入股票的花费buy[1] = max(buy[0], sell[0] - prices[1] - fee) = -3 #第二天执行买入操作sell[1] = max(sell[0], buy[0] + prices[1]) = 0 buy[2] = max(buy[1], sell[1] - prices[2] - fee) = -3 #第三天决定继续持有sell[2] = max(sell[1], buy[1] + prices[2]) = 0 buy[3] = max(buy[2], sell[2] - prices[3] - fee) = -3 #第四天执行卖出操作sell[3] = max(sell[2], buy[2] + prices[3]) = 5 buy[4] = max(buy[3], sell[3] - prices[4] - fee) = -1 #第五天继续购买股票sell[4] = max(sell[3], buy[3] + prices[4]) = 5 buy[5] = max(buy[4], sell[4] - prices[5] - fee) = -1 #第六天卖出sell[5] = max(sell[4], buy[4] + prices[5]) = 8 代码：12345678910111213141516171819class Solution(object): def maxProfit(self, prices, fee): &quot;&quot;&quot; :type prices: List[int] :type fee: int :rtype: int &quot;&quot;&quot; if len(prices) &lt;= 1: return 0 buy, sell = [0] * len(prices), [0] * len(prices) buy[0] = -prices[0] - fee for i in range(1, len(prices)): buy[i] = max(buy[i - 1], sell[i - 1] - prices[i] - fee) sell[i] = max(sell[i - 1], buy[i - 1] + prices[i]) return sell[-1]","link":"/a843781f/"},{"title":"Daily Leetcode 915. Partition Array into Disjoint Intervals","text":"https://leetcode.com/problems/partition-array-into-disjoint-intervals/ Medium 问题描述：Given an array A, partition it into two (contiguous) subarrays left and right so that: Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size. Return the length of left after such a partitioning. It is guaranteed that such a partitioning exists. Example 1: 123Input: [5,0,3,8,6]Output: 3Explanation: left = [5,0,3], right = [8,6] Example 2: 123Input: [1,1,1,0,6,12]Output: 4Explanation: left = [1,1,1,0], right = [6,12] Note: 2 &lt;= A.length &lt;= 30000 0 &lt;= A[i] &lt;= 10^6 It is guaranteed there is at least one way to partition A as described. 题目分析：给定一个数组，我们需要找出一个分界点，使得分界点左边的所有元素均小于右边的元素，同时要保证左边元素个数尽可能的少。 我们可以设置一个变量记录当前分割点，在设置两个变量，一个是leftMax，记录分割点左边元素中的最大值；另一个是utlMax，记录已经遍历过的元素中的最大值。在遍历过程中，比较当前元素和leftMax，如果当前元素比leftMax小，说明当前元素也应该被分割到左边较小的集合中，因此就可以将分割点移动到当前元素的位置，并且将leftMax更新为utlMax。 需要注意的是，题目最终需要的是左边集合的长度，因此，最后返回的结果是分割位置+1。 代码：12345678910111213141516class Solution(object): def partitionDisjoint(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: int &quot;&quot;&quot; leftMax = utlMax = A[0] cutPos = 0 for i in range(len(A)): utlMax = max(utlMax, A[i]) if (A[i] &lt; leftMax): leftMax = utlMax cutPos = i return cutPos + 1","link":"/521875c0/"},{"title":"Daily LeetCode 525. Contiguous Array","text":"https://leetcode.com/problems/contiguous-array/ Medium 问题描述：Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. Example 1: 123Input: [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. Example 2: 123Input: [0,1,0]Output: 2Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Note: The length of the given binary array will not exceed 50,000 题目分析：题目给定了一个由0和1构成的数组，我们需要从这个数组中找出一个长度最长、同时0和1个数相同的子数组。 这一题可以从求数组和入手，我们可以进行一次遍历，在遍历过程中，遇到0则加一，遇到1则减一。 以[0, 1, 0, 1, 1]为例，我们设置三个变量：count代表当前位置记录值，count_dict是一个字典，对应关系是count值:该count值对应位置，初始化为{0:0}，max_length记录当前最大子序列长度。 123456max_length = max(index - count, max_length)index:1, num:0, count:1, max_length:0, count_dict:{0: 0, 1: 1}index:2, num:1, count:0, max_length:2, count_dict:{0: 0, 1: 1}index:3, num:0, count:1, max_length:2, count_dict:{0: 0, 1: 1}index:4, num:1, count:0, max_length:4, count_dict:{0: 0, 1: 1}index:5, num:1, count:-1, max_length:4, count_dict:{0: 0, 1: 1, -1: 5} 需要注意的是，index需要从1开始，这是由于字典初始化包含了key=0，因此需要从1开始。 代码：123456789101112131415161718192021222324class Solution(object): def findMaxLength(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums) == 0 or len(nums) == 1: return 0 count = 0 count_dict = {0: 0} max_length = 0 for i in range(1, len(nums) + 1): if nums[i - 1] == 0: count += 1 else: count -= 1 if count in count_dict: max_length = max(max_length, i - count_dict[count]) else: count_dict[count] = i return max_length","link":"/33521d46/"},{"title":"Daily LeetCode 599. Minimum Index Sum of Two Lists","text":"https://leetcode.com/problems/minimum-index-sum-of-two-lists/ Easy 问题描述：Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer. Example 1: 12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]Output: [&quot;Shogun&quot;]Explanation: The only restaurant they both like is &quot;Shogun&quot;. Example 2: 12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]Output: [&quot;Shogun&quot;]Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1). Note: The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists. 题目分析：这一题其实难度不大，但我一开始看错了题，我以为只要输出一个相对来说两个人都喜欢的餐馆即可。后来各种WA后，才发现，只要index之和相等的餐厅，都需要输出。 这一题需要设置两个字典，分别保存Andy和Doris感兴趣的餐厅restaurant以及对应的index，字典格式为：{restaurant: index}。接着，我们遍历list2，找到相同元素时，将自身index和对应元素在另一个字典中的index相加，寻找最小的index之和，并将最小index和的餐厅添加到res中。 代码：12345678910111213141516171819202122class Solution(object): def findRestaurant(self, list1, list2): &quot;&quot;&quot; :type list1: List[str] :type list2: List[str] :rtype: List[str] &quot;&quot;&quot; min_interest_sum = 999999 Doris_dict = {} res = [] Andy_dict = {restaurant: index for index, restaurant in enumerate(list1)} for index, restaurant in enumerate(list2): if restaurant in Andy_dict: current_interest_sum = index + Andy_dict[restaurant] if current_interest_sum &lt; min_interest_sum: min_interest_sum = current_interest_sum res = [] if current_interest_sum == min_interest_sum: res.append(restaurant) return res","link":"/a57484b0/"},{"title":"Daily LeetCode 724. Find Pivot Index","text":"https://leetcode.com/problems/find-pivot-index/ Easy 问题描述：Given an array of integers nums, write a method that returns the “pivot” index of this array. We define the pivot index as the index where ==the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index==. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. Example 1: 123456Input: nums = [1, 7, 3, 6, 5, 6]Output: 3Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.Also, 3 is the first index where this occurs. Example 2: 12345Input: nums = [1, 2, 3]Output: -1Explanation: There is no index that satisfies the conditions in the problem statement. Note: The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000]. 题目分析：给定一个数组，我们需要找到一个分割点，使得分割点两边的和相等，如果存在多个点，则返回最左边的，如果不存在，则返回-1。 我们只需要一次遍历，就能够解决这个问题。初始状态下的index为0，此时leftSum=0, rightSum=sum(nums)，在遍历过程中，不断更新leftSum, rightSum，就可以找到最左边的分割点。 以题目中所给例子为例，遍历过程中和的更新情况如下： 1234index: 0 , leftSum: 0 , rightSum: 27index: 1 , leftSum: 1 , rightSum: 20index: 2 , leftSum: 8 , rightSum: 17index: 3 , leftSum: 11 , rightSum: 11 --&gt;return index 代码：123456789101112131415class Solution(object): def pivotIndex(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; leftSum, rightSum = 0, sum(nums) for index, num in enumerate(nums): rightSum -= num if leftSum == rightSum: return index leftSum += num return -1","link":"/7419ef34/"},{"title":"Daily LeetCode 648. Replace Words","text":"https://leetcode.com/problems/replace-words/ Medium 问题描述：In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another. Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length. You need to output the sentence after the replacement. Example 1: 123Input: dict = [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]sentence = &quot;the cattle was rattled by the battery&quot;Output: &quot;the cat was rat by the bat&quot; Note: The input will only have lower-case letters. 1 &lt;= dict words number &lt;= 1000 1 &lt;= sentence words number &lt;= 1000 1 &lt;= root length &lt;= 100 1 &lt;= sentence words length &lt;= 1000 题目分析：这一题引用了英语中词根的概念，给定一个dict作为“词根”，例如词根cat，接上tle，就可以组成单词cattle。 我们需要将句子中所有的单词用词根替换，如果字典中有多个词根构成这个单词，那么用最短的词根替换它。 这一题的思路其实很简单，我们采用最暴力的方式，遍历句子中的每个单词，观察这个单词的前缀是否在给定的dict中，若存在则替换。 但这种方式会导致超时问题，在讨论区看到一个优化方法，先将原始给定的dict转换成set，也就是将原来的list转换成set格式。相较于list，查询set的时间复杂度是O(1)，而查询list的时间复杂度是O(n)，因此采用set能够解决超时问题。 代码：12345678910111213141516class Solution(object): def replaceWords(self, dict, sentence): &quot;&quot;&quot; :type dict: List[str] :type sentence: str :rtype: str &quot;&quot;&quot; prefixSet = set(dict) def successorWord(word): for i in range(1, len(word)): if word[:i] in prefixSet: return word[:i] return word return ' '.join(successorWord(word) for word in sentence.split(' ')) 前缀树解法：将dict存放到一个前缀树中，这样我们就可以在线性时间内进行前缀的查询 以题中dict为例，建立的前缀树如图所示： 代码（LeetCode）： 1234567891011121314151617181920212223class Solution(object): def replaceWords(self, roots, sentence): Trie = lambda: collections.defaultdict(Trie) trie = Trie() END = True for root in roots: cur = trie for letter in root: cur = cur[letter] cur[END] = root def replace(word): cur = trie for letter in word: if letter not in cur: break cur = cur[letter] if END in cur: return cur[END] return word return &quot; &quot;.join(map(replace, sentence.split()))","link":"/bc86db44/"},{"title":"Daily LeetCode 3. Longest Substring Without Repeating Characters","text":"https://leetcode.com/problems/longest-substring-without-repeating-characters/ Medium 问题描述Given a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 题目分析：给定一个字符串，要求输出最长的不包含重复字符的子串。注意是子串而不是子序列，因此一定要是连续的。 可以从我们自己的思考方式入手解决这个问题，以题中Example 1为例，当字符串为&quot;abcabcbb&quot;时，我们先从第一个字母a向后看，当遇到下一个a时，我们可以选择将已经找到的子串abc中的a去掉，此时最长子串变成了bca继续向后，遇到下一个b，同样，我们去掉b，此时最长子串变成了cab，以此类推，我们最终发现最长子串长度为3。 因此，我们需要一个dict来记录已遍历的字符出现的位置，在遍历过程中，不断更新dict内容。当遇到未出现过的字符时，我们只需要扩大子串长度即可；当遇到已经在dict中的字符时，我们需要一个变量来记录当前子串的最左位置，如果当前字符位置在子串中，为了保证没有重复元素，我们需要比较前后子串长度，保留较长的那个。 以Example 1为例： 12345678leftPos: 0, ch_dict:{'a': 0}, max_length:1leftPos: 0, ch_dict:{'b': 1, 'a': 0}, max_length:2leftPos: 0, ch_dict:{'c': 2, 'b': 1, 'a': 0}, max_length:3leftPos: 1, ch_dict:{'c': 2, 'b': 1, 'a': 3}, max_length:3leftPos: 2, ch_dict:{'c': 2, 'b': 4, 'a': 3}, max_length:3leftPos: 3, ch_dict:{'c': 5, 'b': 4, 'a': 3}, max_length:3leftPos: 5, ch_dict:{'c': 5, 'b': 6, 'a': 3}, max_length:3leftPos: 7, ch_dict:{'c': 5, 'b': 7, 'a': 3}, max_length:3 代码：123456789101112131415161718class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; leftPos, maxLength = 0, 0 ch_dict = {} for index, ch in enumerate(s): if ch in ch_dict and leftPos &lt;= ch_dict[ch]: leftPos = ch_dict[ch] + 1 else: maxLength = max(maxLength, index - leftPos + 1) ch_dict[ch] = index return maxLength","link":"/3c56e325/"},{"title":"Daily LeetCode 848. Shifting Letters","text":"https://leetcode.com/problems/shifting-letters/ Medium 问题描述：We have a string S of lowercase letters, and an integer array shifts. Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a'). For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'. Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times. Return the final string after all such shifts to S are applied. Example 1: 1234567Input: S = &quot;abc&quot;, shifts = [3,5,9]Output: &quot;rpl&quot;Explanation: We start with &quot;abc&quot;.After shifting the first 1 letters of S by 3, we have &quot;dbc&quot;.After shifting the first 2 letters of S by 5, we have &quot;igc&quot;.After shifting the first 3 letters of S by 9, we have &quot;rpl&quot;, the answer. Note: 1 &lt;= S.length = shifts.length &lt;= 20000 0 &lt;= shifts[i] &lt;= 10 ^ 9 题目分析：我们用题目中的例子来解释这条题目的含义： 给定字符串S=&quot;abc&quot;，以及偏移数组shifts=[3, 5, 9]，我们需要对S进行偏移操作： 1234shifts[1] = 3，则将字符串中的前一个字符偏移三位，此时字符串变成&quot;dbc&quot;shifts[2] = 5，则将字符串中的前两个字符偏移五位，此时字符串变成&quot;igc&quot;shifts[3] = 9，则将字符串中的前三个字符偏移九位，此时字符串变成&quot;rpl&quot;最终返回字符串&quot;rpl&quot; 这一题有两个要点：第一个要点是，我们可以将shift数组转换成对应的和数组，shift[i]表示对S[0:i]范围内的所有字符进行偏移操作，我们可以对shift数组执行反向累加和操作，那么第i项就是对应的第i个字符需要偏移的位数；第二个要点是，在得到了每个字符需要偏移的位数后，我们还需要考虑当前字符偏移到z后的后续处理，我们可以先算出当前字符到a的距离，加上偏移值后对26取余，得到偏移后的字符与a的距离，再加上a，就可以得到偏移后的字符。 还有一点需要注意，我最开始交的代码存在超时的问题，主要是因为我分别计算了反向累加和，多了几个循环，虽然都是O(n)的复杂度，但是在n的系数过大的情况下，就会导致超时。 代码：12345678910111213141516class Solution(object): def shiftingLetters(self, S, shifts): &quot;&quot;&quot; :type S: str :type shifts: List[int] :rtype: str &quot;&quot;&quot; current_sum = sum(shifts) start = ord('a') res = &quot;&quot; for index in range(len(shifts)): res += chr((ord(S[index]) + current_sum - start) % 26 + start) current_sum -= shifts[index] return res","link":"/88edcfac/"},{"title":"Daily LeetCode 322. Coin Change","text":"https://leetcode.com/problems/coin-change/ Medium 问题描述：You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: 123Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: 12Input: coins = [2], amount = 3Output: -1 Note:You may assume that you have an infinite number of each kind of coin. 题目分析：给定硬币种类，我们需要找出最少的硬币数达成目标和。 这一题我最先想到的解法是暴力解法，但会导致超时。这种类型的题目，动态规划是一个好的选择。设置一个长度为amount + 1的数组dp，dp[i]表示以当前的硬币种类，达成目标和i所需的最少硬币数。dp[i] = min(dp[i], d[i - coin] + 1)，coin是所有小于当前和的硬币值。 以Example 1为例，amount = 11，我们设置一个长度为12的数组，这个动态规划数组在遍历过程中的值变化如下，其中，inf为无穷大： 1234567891011dp:[0, 1, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf]dp:[0, 1, 1, inf, inf, inf, inf, inf, inf, inf, inf, inf]dp:[0, 1, 1, 2, inf, inf, inf, inf, inf, inf, inf, inf]dp:[0, 1, 1, 2, 2, inf, inf, inf, inf, inf, inf, inf]dp:[0, 1, 1, 2, 2, 1, inf, inf, inf, inf, inf, inf]dp:[0, 1, 1, 2, 2, 1, 2, inf, inf, inf, inf, inf]dp:[0, 1, 1, 2, 2, 1, 2, 2, inf, inf, inf, inf]dp:[0, 1, 1, 2, 2, 1, 2, 2, 3, inf, inf, inf]dp:[0, 1, 1, 2, 2, 1, 2, 2, 3, 3, inf, inf]dp:[0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, inf]dp:[0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3] 代码：123456789101112131415class Solution(object): def coinChange(self, coins, amount): &quot;&quot;&quot; :type coins: List[int] :type amount: int :rtype: int &quot;&quot;&quot; dp = [0] + [float('inf')] * amount for i in range(1, amount + 1): for coin in coins: if coin &lt;= i: dp[i] = min(dp[i], dp[i - coin] + 1) return -1 if dp[amount] == float('inf') else dp[amount]","link":"/6844429/"},{"title":"Daily LeetCode 739. Daily Temperatures","text":"https://leetcode.com/problems/daily-temperatures/ Medium 问题描述：Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0]. Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100]. 分析：给定气温序列，求解第i天需要过几天才能升温，实际上就是寻找数组右边第一个比当前元素大的元素。 最开始我的想法是使用暴力解法解决这题，我们只需要从当前元素的位置向右遍历，记录下遇到的第一个比当前元素大的元素位置即可，但这种方法会导致超时。 我们改用栈来解决这个问题，初始化一个栈，==栈中记录当前元素对应的index==。对气温序列进行正序遍历，当栈顶元素小于当前气温时，说明找到了当前栈顶元素右边第一个较大的元素，我们记录当前元素位置即可。 具体来说： 12345678current_stack: [0], res: [0, 0, 0, 0, 0, 0, 0, 0]current_stack: [1], res: [1, 0, 0, 0, 0, 0, 0, 0] #在index=1时，找到了74，大于73，因此res[0] = 1current_stack: [2], res: [1, 1, 0, 0, 0, 0, 0, 0] current_stack: [2, 3], res: [1, 1, 0, 0, 0, 0, 0, 0]current_stack: [2, 3, 4], res: [1, 1, 0, 0, 0, 0, 0, 0]current_stack: [2, 5], res: [1, 1, 0, 2, 1, 0, 0, 0]current_stack: [6], res: [1, 1, 4, 2, 1, 1, 0, 0]current_stack: [6, 7], res: [1, 1, 4, 2, 1, 1, 0, 0] 代码：1234567891011121314151617class Solution(object): def dailyTemperatures(self, T): &quot;&quot;&quot; :type T: List[int] :rtype: List[int] &quot;&quot;&quot; stack = [] res = [0] * len(T) for index, value in enumerate(T): while stack and value &gt; T[stack[-1]]: top = stack.pop() res[top] = index - top stack.append(index) return res","link":"/a58eb997/"},{"title":"Linux进程控制块","text":"这是操作系统老师布置的一项作业，作业内容如下： 试根据你自己的理解，采用类C语言设计和描述操作系统关于进程控制块的数据结构、组织方式及管理机制。在此基础上，给出进程的创建、终止、阻塞、唤醒、挂起与激活等函数原型及函数代码。注意，对于过于复杂的功能或你无法解决的细节可采用指定功能的函数模块如处理机scheduler()调度来替代。 这篇文章首先介绍了Linux操作系统中的进程控制块task_struct，再根据《操作系统原理》中的描述写了进程调度的伪代码。 进程​ Linux中的每个进程由一个task_struct数据结构来描述，这个结构体容纳了一个进程的所有信息，是系统对进程进行控制的唯一手段，也是最有效的手段。 ​ 我使用PD在电脑中安装了Linux虚拟机，内核版本为4.13.0-37，task_struct结构体定义在sched.h文件中，具体路径如下图： ​ Linux支持两种进程：普通进程和实时进程。实时进程具有一定程度上的紧迫性，要求对外部事件做出非常快的响应；而普通进程则没有这种限制。所以，调度程序要区分对待这两种进程，通常，实时进程比普通进程优先运行。 task_struct成员 进程状态(state) 进程执行时，它会根据具体情况改变状态。进程状态是调度和对换的依据。 1volatile long state; state的可能取值如下： 五个互斥状态 state域能够取的这五个值互为排斥。 状态描述TASK_RUNNING可运行状态，要么正在运行、要么准备运行。正在运行的进程就是current指向的进程，准备运行的进程等待CPU片的调度。TASK_INTERRUPTIBLE可中断的等待状态，该状态的进程正在等待某个事件或某个资源，它位于系统中的某个等待队列中，可以被信号唤醒。TASK_UNINTERRUPTIBLE不可中断的等待状态，等待特定的系统资源，不可被打断，只能用特定的方式唤醒，例如唤醒函数wake_up()等。__TASK_STOPPED暂停状态，进程接收到SIGSTOP, SIGTTIN, SIGTSTP或者SIGTTOU信号后进入该状态。__TASK_TRACED表示进程被debugger等进程监视，进程执行被调试程序所停止。 两个终止状态 123int exit_state;int exit_code;int exit_signal; 两个附加的进程状态既可以添加到state域中，又可以添加到exit_state域中。当进程终止时，会达到这两种状态。 状态描述EXIT_DEAD进程的最终状态。EXIT_ZOMBIE进程的执行被终止，但是其父进程还未使用wait()等系统调用来获知它的终止信息，此时进程成为僵尸进程。 睡眠状态 TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE都是睡眠状态。 内核提供了两种方法将进程置为睡眠状态： 将进程设置为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE，并且调用schedule()函数。将进程从CPU运行队列中移除。 TASK_KILLABLE状态 状态描述TASK_KILLABLE当进程处于这种可终止的睡眠状态中时，可以响应致命信号 123456#define TASK_WAKEKILL 128/* Convenience macros for the sake of set_current_state: */#define TASK_KILLABLE (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)#define TASK_STOPPED (TASK_WAKEKILL | __TASK_STOPPED)#define TASK_TRACED (TASK_WAKEKILL | __TASK_TRACED) 即TASK_KILLABLE = TASK_WAKEKILL + TASK_UNINTERRUPTIBLE。 参考：https://www.ibm.com/developerworks/cn/linux/l-task-killable/index.html 进程标识符(PID) 12pid_t pid;pid_t tgid; 每个进程都有一个唯一的标识符，内核通过这个标识符来识别不同的进程，同时，进程标识符PID也是内核提供给用户程序的接口，用户程序通过PID对进程发号施令。PID是32位的无符号整数，顺序编号，新创建的进程通常是前一个进程的PID加1，Linux上允许的最大PID号为32767。 线程组所有线程与领头线程具有相同的PID，存入tgid字段，getpid()返回当前进程的tgid值。 进程内核栈 1void *stack 对每个进程，Linux内核把两个不同的数据结构紧凑的存放在一个单独为进程分配的内存区域中： 内核态的进程堆栈 线程描述符thread_info Linux把这两个结构存放在一起，区域通常占8192K。 esp寄存器是CPU的栈指针，存放栈顶单元地址。 内核栈数据结构描述thread_info 1234567#ifdef CONFIG_THREAD_INFO_IN_TASK /* * For reasons of header soup (see current_thread_info()), this * must be the first element of task_struct. */ struct thread_info thread_info;#endif thread_info结构定义在thread_info.h中： 进程标记 12/* Per task flags (PF_*), defined further below: */unsigned int flags; 反应进程状态的信息，但不是运行状态，用于内核识别进程当前的状态，以备下一步操作 flags成员的可能取值如下，这些宏以PF(ProcessFlag)开头。 表示进程亲属关系成员 123456789101112131415161718/* * Pointers to the (original) parent process, youngest child, younger sibling, * older sibling, respectively. (p-&gt;father can be replaced with * p-&gt;real_parent-&gt;pid) *//* Real parent process: */struct task_struct __rcu *real_parent;/* Recipient of SIGCHLD, wait4() reports: */struct task_struct __rcu *parent;/* * Children/sibling form the list of natural children: */struct list_head children;struct list_head sibling;struct task_struct *group_leader; 在Linux系统中，每个进程都有其父进程，也可能有零个或多个子进程。拥有同一父进程的所有进程具有兄弟关系。 进程调度 优先级 1234int prio; //保存动态优先级int static_prio; //保存静态优先级int normal_prio; //取值取决于静态优先级和调度策略unsigned int rt_priority; //保存实时优先级 实时优先级范围是0至MAX_RT_PRIO-1，普通进程的静态优先级范围是从MAX_RT_PRIO到MAX_PRIO-1。值越大静态优先级越低。 MAX_RT_PRIO定义在prio.h中： 调度策略相关字段 1234567const struct sched_class *sched_class;struct sched_entity se;struct sched_rt_entity rt; unsigned int policy;int nr_cpus_allowed;cpumask_t cpus_allowed; 字段描述policy调度策略sched_class调度类se普通进程的调用实体，每个进程都有其中之一的实体rt实时进程的调用实体，每个进程都有其中之一的实体cpus_allowed控制进程可以在哪里处理器上运行 时间 一个进程从创建到终止叫做该进程的生存期（lifetime）。进程在其生存期内使用 CPU 的时间，内核都要进行记录，以便进行统计、计费等有关操作。进程耗费 CPU 的时间由两部 分组成：一是在用户模式（或称为用户态）下耗费的时间、一是在系统模式（或称为系统态） 下耗费的时间。每个时钟滴答，也就是每个时钟中断，内核都要更新当前进程耗费 CPU 的时 间信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445u64 utime;u64 stime;#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME u64 utimescaled; u64 stimescaled;#endifu64 gtime;struct prev_cputime prev_cputime;#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN struct vtime vtime;#endif/* Context switch counts: */unsigned long nvcsw;unsigned long nivcsw;/* Monotonic time in nsecs: */u64 start_time;/* Boot based time in nsecs: */u64 real_start_time;/* MM fault and swap info: this can arguably be seen as either mm-specific or thread-specific: */unsigned long min_flt;unsigned long maj_flt;#ifdef CONFIG_POSIX_TIMERS struct task_cputime cputime_expires; struct list_head cpu_timers[3];#endif/* Process credentials: *//* Tracer's credentials at attach: */const struct cred __rcu *ptracer_cred;/* Objective and real subjective task credentials (COW): */const struct cred __rcu *real_cred;/* Effective (overridable) subjective task credentials (COW): */const struct cred __rcu *cred; struct nameidata *nameidata;#ifdef CONFIG_SYSVIPC struct sysv_sem sysvsem; struct sysv_shm sysvshm;#endif#ifdef CONFIG_DETECT_HUNG_TASK unsigned long last_switch_count;#endif 字段描述utime/stime用于记录进程在用户态/内核态下所经过的节拍数prev_utime/prev_stime先前运行时间utimescaled/stimescaled记录进程在用户态/内核态的运行时间gtime用节拍计数的虚拟机运行时间nvcsw/nivcsw是自愿（voluntary）/非自愿（involuntary）上下文切换计数last_switch_countnvcsw和nivcsw总和start_time/real_start_time进程创建时间cputime_expires统计进程或进程组被跟踪的处理器时间 信号处理 1234567891011/* Signal handlers: */struct signal_struct *signal;struct sighand_struct *sighand;sigset_t blocked;sigset_t real_blocked;/* Restored if set_restore_sigmask() was used: */sigset_t saved_sigmask;struct sigpending pending;unsigned long sas_ss_sp;size_t sas_ss_size;unsigned int sas_ss_flags; 字段描述signal指向进程的信号描述符sighand指向进程的信号处理程序描述符blocked表示被阻塞信号的掩码pending存放私有挂起信号sas_ss_sp信号处理程序备用堆栈地址 进程组织方式 线性方式 把所有的task_struct组织在一张线性表中，将该表的首地址存放在内存的一个专用区域中，该方法实现简单、开销小，但每次查找需要扫描全表，适用于系统中进程数目不多的情况。 链接方式 把具有相同状态进程的task_struct分别通过task_struct中的链接字链接成一个队列。形成就绪队列、若干个阻塞队列和空白队列等。 索引方式 根据所有进程状态不同建立索引表，各个索引表在内存单元中的首地址也记录在内存中的专用单元中，用添加索引表的方式记录具有相应状态下的某个PCB在PCB表中的地址。 进程控制函数原型及代码创建、终止、阻塞、唤醒、挂起与激活 进程创建 创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程。 在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语)： 分配标识符，并申请空白进程控制块 为新进程的程序和数据及用户栈分配必要的内存空间 初始化进程控制块：自身/父进程标识符，处理机状态/调度信息 将新进程插入到就绪进程队列 1234567int create(struct task *task_struct, struct preparedQueue *q) { task_struct = (struct task *)malloc(sizeof(struct task)); //分配内存空间 task_struct-&gt;pid = getpid();//进程标识符 ……………… //初始化进程控制块 insert(q, task_struct); //把当前控制块插入就绪进程队列 return pid;} 进程终止 引起进程终止的事件主要有：正常结束，表示进程的任务已经完成和准备退出运行。异常结束，指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等。外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。 操作系统终止进程的过程如下（撤销原语）： 根据被终止进程的标识符，检索PCB，从中读出该进程的状态。 若被终止进程处于执行状态，立即终止该进程的执行，置调度标志为真，用于指示该进程被终止后应重新进行调度。 若该进程还有子进程，则应将其所有子进程终止。 将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。 将该PCB从所在队列（链表）中删除。 12345678910111213141516void Terminate(pid, q, task_struct) { volatile long state; //进程状态 bool flag; //调度标志 //处于运行状态，则终止进程执行，置调度标志为真。 if(getState(pid) == running){ kill(pid); flag = true; } //终止所有子进程 if(isHaveSonNodes(pid)) { killAllSonNodes(pid); } free(task_struct); //归还资源 delete(q, task_struct); //从队列中删除} 进程阻塞 正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。 阻塞原语的执行过程是： 找到将要被阻塞进程的标识号对应的PCB。 若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。 把该PCB插入到相应事件的等待队列中去。 123456void Block(task_struct, pid, blockQueue q) { task_struct = getRunningTask(pid); //找到对应的PCB stop(task_struct); //停止运行 task_struct-&gt;state = blocked; //转为阻塞状态 insert(q, task_struct); //插入等待队列} 进程唤醒 当被阻塞进程所期待的事件出现时，如它所启动的I/O操作已完成或其所期待的数据已到达，则由有关进程（比如，提供数据的进程）调用唤醒原语(Wakeup)，将等待该事件的进程唤醒。 唤醒原语的执行过程是： 在该事件的等待队列中找到相应进程的PCB。 将其从等待队列中移出，并置其状态为就绪状态。 把该PCB插入就绪队列中，等待调度程序调度。 123456void wakeUp (pid, task_struct, blockedQueue p, preparedQueue q) { task_struct = getBlockedTask(pid); //找到对应的PCB remove(p, task_struct); //从等待队列移出 tast_struct-&gt;state = ready; //状态改为就绪 insert(q, task_struct); //插入就绪队列} 进程挂起 检查被挂进程现行状态并修改和插队 复制PCB到指定区域 若被挂进程正在执行则转向调度程序重新调度 123456789101112131415161718void Suspend(pid, task_struct) { int state = task_struct-&gt;state; if(task_struct-&gt;state = &quot;running&quot;) { stop(task_struct); } copy(task_struct); switch(state) { case &quot;活动就绪&quot;: task_struct-&gt;state = &quot;静止就绪&quot;; break; case &quot;活动阻塞&quot;: task_struct-&gt;state = &quot;静止阻塞&quot;; break; } if(task_struct-&gt;state = &quot;running&quot;) { scheduler(); }} 进程激活 检查进程现行状态并修改和插队 若有新进程进入就绪队列且采用了抢占式调度策略，则检查和决定是否重新调度 123456789101112131415void Active(pid, task_struct) { int state = task_struct-&gt;state; scheduler(); //将挂起的进程从外存调入内存 switch(state) { case &quot;静止就绪&quot;: task_struct-&gt;state = &quot;活动就绪&quot;; break; case &quot;静止阻塞&quot;: task_struct-&gt;state = &quot;活动阻塞&quot;; break; } if(task_struct-&gt;state == &quot;ready&quot;) { scheduler(); //若有新进程进入就绪队列且采用了抢占式调度策略，则检查和决定是否重新调度 }}","link":"/ce94ceda/"},{"title":"Linux处理器调度","text":"调度程序决定将哪个进程投入运行、何时运行以及运行多长时间。调度程序可以当做在可运行态进程之间分配有限的处理器时间资源的内核子系统。只有通过调度程序的合理调度，系统资源才能最大限度发挥作用，多进程才能够有并发执行效果。 本文源码版本4.16.7 查看源码 参考图书：Linux内核设计与实现 多任务分类 非抢占式多任务 除非任务自己结束，否则会一直执行 抢占式多任务 由调度程序决定什么时候停止一个进程的运行。采用抢占式多任务的基础是使用时间片轮转机制来为每个进程分配可以运行的时间单位。 Linux进程调度的发展Linux从2.5版本开始使用一种叫做O(1)的调度程序，这种调度程序对于大服务器的工作负载很理想，但是由于缺少交互进程，在桌面系统上表现不佳。因此，从2.6版本开始，Linux开始使用“完全公平调度算法”（CFS）。 策略 I/O消耗型和处理器消耗型进程 I/O消耗型进程是指大部分时间都用来提交I/O请求或者等待I/O请求的进程，这样的进程经常处于可运行状态，但运行时间通常较短，因为它在等待更多的I/O请求的过程中总会阻塞。例如大多数的用户图形界面程序都属于I/O密集型的程序，多数时间都在等待来自鼠标或键盘的用户交互操作。 处理器耗费进程则把大多数时间用来执行代码，调度策略往往会尽量降低这种进程的调度频率，延长其运行时间。例如MATLAB等执行大量数学计算的程序。 调度策略往往在两个矛盾的目标中寻找平衡：进程响应迅速和最大系统利用率，Linux为了保证交互式应用和桌面系统的性能，对进程响应做了优化，更倾向于优先调度I/O消耗型进程。 进程优先级 Linux采用了两种不同的优先级范围。 nice值 nice值范围是-20~+19，默认为0；越大的nice值意味着更低的优先级。 实时优先级 实时优先级的值可配置，默认情况下范围是0~99。与nice值意义相反，越高的实时优先级数值意味着进程优先级越高。 时间片 时间片的含义是进程在被抢占前所能持续运行的时间。Linux中并没有直接分配默认时间片，而是将处理器的使用比划分给进程。进程获得的处理器时间与系统负载密切相关，这个比例还会受到nice值的影响。 调度算法 调度器类 Linux调度器以模块方式提供，使得不同类型的进程可以有针对性地选择调度算法。基础的调度器会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，由它来选择下一个要执行的进程。CFS就是一个针对普通进程的调度类。 公平调度 CFS的出发点基于一个简单的理念：进程调度的效果应如同系统具备一个理想中的完美多任务处理器。我们可以给任何进程调度无限小的时间周期，所以在任何可测量范围内，可以给n个进程相同多的运行时间。 举个例子来区分Unix调度和CFS：有两个运行的优先级相同的进程，在Unix中可能是每个各执行5ms，执行期间完全占用处理器，但在“理想情况”下，应该是，能够在10ms内同时运行两个进程，每个占用处理器一半的能力。 CFS的做法：允许每个进程允许一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法。CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。 接下来我们考虑调度周期，理论上，调度周期越小，就越接近“完美调度”，但实际上这必然会带来严重的上下文切换消耗。在CFS中，为能够实现的最小调度周期设定了一个近似值目标，称为“目标延迟”，于此同时，为了避免不可接受的上下文切换消耗，为每个进程所能获得的时间片大小设置了一个底线——最小粒度（通常为1ms）。 在每个进程的平均运行时间大于最小粒度的情况下，CFS无疑是公平的，nice值用于计算一个进程在当前这个最小调度周期中所应获得的处理器时间占比，这样就算nice值不同，只要差值相同，总是能得到相同的时间片。我们假设一个最小调度周期为20ms，两个进程的nice值差值为5： 两进程的nice值分别为0和5，后者获得的时间片是前者的1/3，因此最终分别获得15ms和5ms 两进程的nice值分别为10和15，后者获得的时间片是前者的1/3，最终结果也是15ms和5ms Linux调度的实现分别分析四个组成部分： 时间记账 所有的调度器都必须对进程运行时间记录。 调度器实体结构 CFS使用调度器实体结构来追踪进程运行记账，这个结构体定义在&lt;linux/sched.h&gt;的struct_sched_entity中，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637struct sched_entity { /* 用于调度均衡的相关变量，主要与红黑树有关 */ struct load_weight load; //权重，与优先级有关 unsigned long runnable_weight; //在所有可运行进程中所占的权重 struct rb_node run_node; //红黑树结点 struct list_head group_node; //所在进程组 unsigned int on_rq; //标记是否处于红黑树运行队列中 u64 exec_start; //开始执行时间 u64 sum_exec_runtime; //总运行时间 u64 vruntime; //虚拟运行时间 u64 prev_sum_exec_runtime; //上个调度周期中运行的总时间 u64 nr_migrations; struct sched_statistics statistics;//设置了CONFIG_FAIR_GROUP_SCHED才启用的变量#ifdef CONFIG_FAIR_GROUP_SCHED int depth; struct sched_entity *parent; /* rq on which this entity is (to be) queued: */ struct cfs_rq *cfs_rq; /* rq &quot;owned&quot; by this entity/group: */ struct cfs_rq *my_q;#endif#ifdef CONFIG_SMP /* * Per entity load average tracking. * * Put into separate cache line so it does not * collide with read-mostly values above. */ struct sched_avg avg ____cacheline_aligned_in_smp;#endif}; 虚拟实时vruntime 我们称vruntime为虚拟运行时间，该运行时间的计算是经过了所有可运行进程总数的标准化（加权）。以ns为单位，与定时器节拍无关。 可以认为这是CFS为了能够实现理想多任务处理而不得不虚拟的一个新的时钟，具体地讲，一个进程的vruntime会随着运行时间的增加而增加，但这个增加的速度由它所占的权重load来决定。 结果就是权重越高，增长越慢：所得到的调度时间也就越小 —— CFS用它来记录一个程序到底运行了多长时间以及还应该运行多久。 记账功能实现源码kernel/sched/fair.c： 12345678910111213141516171819202122232425262728293031323334353637static void update_curr(struct cfs_rq *cfs_rq){ struct sched_entity *curr = cfs_rq-&gt;curr; u64 now = rq_clock_task(rq_of(cfs_rq)); u64 delta_exec; if (unlikely(!curr)) return; //获得从最后一次修改负载后当前任务所占用的运行总时间 delta_exec = now - curr-&gt;exec_start; if (unlikely((s64)delta_exec &lt;= 0)) return; //更新执行开始时间 curr-&gt;exec_start = now; schedstat_set(curr-&gt;statistics.exec_max, max(delta_exec, curr-&gt;statistics.exec_max)); curr-&gt;sum_exec_runtime += delta_exec; schedstat_add(cfs_rq-&gt;exec_clock, delta_exec); //计算虚拟时间 curr-&gt;vruntime += calc_delta_fair(delta_exec, curr); update_min_vruntime(cfs_rq); if (entity_is_task(curr)) { struct task_struct *curtask = task_of(curr); trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime); cgroup_account_cputime(curtask, delta_exec); account_group_exec_runtime(curtask, delta_exec); } account_cfs_rq_runtime(cfs_rq, delta_exec);} 该函数计算了当前进程的执行时间，并且将其存放在变量delta_exec中。然后使用clac_delta_fair函数计算虚拟运行时间，更新vruntime的值。 这个函数是由系统定时器周期性调用的（无论进程的状态是什么），因此vruntime可以准确地测量给定进程的运行时间，并以此为依据推断出下一个要运行的进程是什么。 进程选择 CFS需要选择下一个运行进程时，它会挑选一个具有最小vruntime的进程，这就是CFS算法的核心。 CFS使用红黑树来组织可运行进程队列。 红黑树是一种自平衡二叉树，它是一种以树节点方式储存数据的结构，每个节点对应了一个键值，利用这个键值可以快速索引树上的数据，并且它可以按照一定的规则自动调整每个节点的位置，使得通过键值检索到对应节点的速度和整个树节点的规模呈指数比关系。 挑选下一个任务 先假设一个红黑树储存了系统中所有的可运行进程，节点的键值就是它们的vruntime，CFS现在要找到下一个需要调度的进程，是所有进程中vruntime最小的那个，对应树中最左侧的叶子节点。 具体实现过程如下kernel/sched/fair.c： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static struct sched_entity *pick_next_entity(struct cfs_rq *cfs_rq, struct sched_entity *curr){ struct sched_entity *left = __pick_first_entity(cfs_rq); struct sched_entity *se; /* * If curr is set we have to see if its left of the leftmost entity * still in the tree, provided there was anything in the tree at all. */ if (!left || (curr &amp;&amp; entity_before(curr, left))) left = curr; se = left; /* ideally we run the leftmost entity */ /* * 下面过程针对一些特殊情况 * Avoid running the skip buddy, if running something else can * be done without getting too unfair. */ if (cfs_rq-&gt;skip == se) { struct sched_entity *second; if (se == curr) { second = __pick_first_entity(cfs_rq); } else { second = __pick_next_entity(se); if (!second || (curr &amp;&amp; entity_before(curr, second))) second = curr; } if (second &amp;&amp; wakeup_preempt_entity(second, left) &lt; 1) se = second; } /* * Prefer last buddy, try to return the CPU to a preempted task. */ if (cfs_rq-&gt;last &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;last, left) &lt; 1) se = cfs_rq-&gt;last; /* * Someone really wants this to run. If it's not unfair, run it. */ if (cfs_rq-&gt;next &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;next, left) &lt; 1) se = cfs_rq-&gt;next; clear_buddies(cfs_rq, se); return se;} 向树中加入进程 进程由阻塞态被唤醒或者fork产生新的进程时，需要执行插入新节点工作。enqueue_entity()函数实现了将进程加入红黑树以及缓存最左叶子节点的过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static voidenqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags){ bool renorm = !(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_MIGRATED); bool curr = cfs_rq-&gt;curr == se; /* * 如果加入的进程是当前正在运行的进程，我们需要重新规范化vruntime * 更新当前任务的统计数据 */ if (renorm &amp;&amp; curr) se-&gt;vruntime += cfs_rq-&gt;min_vruntime; update_curr(cfs_rq); /* * Otherwise, renormalise after, such that we're placed at the current * moment in time, instead of some random moment in the past. Being * placed in the past could significantly boost this task to the * fairness detriment of existing tasks. */ if (renorm &amp;&amp; !curr) se-&gt;vruntime += cfs_rq-&gt;min_vruntime; /* * 更新对应调度器实体的记录值 * When enqueuing a sched_entity, we must: * - Update loads to have both entity and cfs_rq synced with now. * - Add its load to cfs_rq-&gt;runnable_avg * - For group_entity, update its weight to reflect the new share of * its group cfs_rq * - Add its new weight to cfs_rq-&gt;load.weight */ update_load_avg(cfs_rq, se, UPDATE_TG | DO_ATTACH); update_cfs_group(se); enqueue_runnable_load_avg(cfs_rq, se); account_entity_enqueue(cfs_rq, se); if (flags &amp; ENQUEUE_WAKEUP) place_entity(cfs_rq, se, 0); check_schedstat_required(); update_stats_enqueue(cfs_rq, se, flags); check_spread(cfs_rq, se); if (!curr) __enqueue_entity(cfs_rq, se); //插入过程 se-&gt;on_rq = 1; if (cfs_rq-&gt;nr_running == 1) { list_add_leaf_cfs_rq(cfs_rq); check_enqueue_throttle(cfs_rq); }} 上述函数用来更新运行时间和对应调度器实体的各种统计数据，然后调用__enqueue_entity()函数来执行插入红黑树的操作： 12345678910111213141516171819202122232425262728static void __enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se){ struct rb_node **link = &amp;cfs_rq-&gt;tasks_timeline.rb_root.rb_node; struct rb_node *parent = NULL; struct sched_entity *entry; bool leftmost = true; /* * 在红黑树中搜索合适位置 */ while (*link) { parent = *link; entry = rb_entry(parent, struct sched_entity, run_node); /* * 具有相同键值得结点放在一起 */ if (entity_before(se, entry)) { link = &amp;parent-&gt;rb_left; } else { link = &amp;parent-&gt;rb_right; leftmost = false; } } rb_link_node(&amp;se-&gt;run_node, parent, link); rb_insert_color_cached(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline, leftmost);} while()循环遍历树寻找匹配键值，找到后对插入位置父节点执行rb_link_node()，最后更新红黑树的自平衡属性。 从树中删除进程 进程执行完毕或受到阻塞时需要删除： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static voiddequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags){ /* * 更新当前进程的统计数据 */ update_curr(cfs_rq); /* * When dequeuing a sched_entity, we must: * - Update loads to have both entity and cfs_rq synced with now. * - Substract its load from the cfs_rq-&gt;runnable_avg. * - Substract its previous weight from cfs_rq-&gt;load.weight. * - For group entity, update its weight to reflect the new share * of its group cfs_rq. */ update_load_avg(cfs_rq, se, UPDATE_TG); dequeue_runnable_load_avg(cfs_rq, se); update_stats_dequeue(cfs_rq, se, flags); clear_buddies(cfs_rq, se); if (se != cfs_rq-&gt;curr) __dequeue_entity(cfs_rq, se); se-&gt;on_rq = 0; account_entity_dequeue(cfs_rq, se); /* * 重新规范化vruntime * Normalize after update_curr(); which will also have moved * min_vruntime if @se is the one holding it back. But before doing * update_min_vruntime() again, which will discount @se's position and * can move min_vruntime forward still more. */ if (!(flags &amp; DEQUEUE_SLEEP)) se-&gt;vruntime -= cfs_rq-&gt;min_vruntime; /* return excess runtime on last dequeue */ return_cfs_rq_runtime(cfs_rq); update_cfs_group(se); /* * Now advance min_vruntime if @se was the entity holding it back, * except when: DEQUEUE_SAVE &amp;&amp; !DEQUEUE_MOVE, in this case we'll be * put back on, and if we advance min_vruntime, we'll be placed back * further than we started -- ie. we'll be penalized. */ if ((flags &amp; (DEQUEUE_SAVE | DEQUEUE_MOVE)) == DEQUEUE_SAVE) update_min_vruntime(cfs_rq);} 实际删除操作由__dequeue_entity()实现： 1234static void __dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se){ rb_erase_cached(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);} 调度器入口 进程调度的主要入口函数是schedule()，该函数会找到一个最高优先级的调度类，然后向其询问下一个要运行的进程是谁。 该函数中唯一重要的事情就是调用pick_next_task()函数，该函数以优先级为序，从高到低依次检查每一个调度类，从最高优先级的调度类中选择最高优先级的进程： 123456789101112131415161718192021222324252627282930313233343536373839404142static inline struct task_struct *pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf){ const struct sched_class *class; struct task_struct *p; /* * 如果当前所有要调度的进程都是普通进程，那么就直接采用CFS * Optimization: we know that if all tasks are in the fair class we can * call that function directly, but only if the @prev task wasn't of a * higher scheduling class, because otherwise those loose the * opportunity to pull in more work from other CPUs. */ if (likely((prev-&gt;sched_class == &amp;idle_sched_class || prev-&gt;sched_class == &amp;fair_sched_class) &amp;&amp; rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev, rf); if (unlikely(p == RETRY_TASK)) goto again; /* Assumes fair_sched_class-&gt;next == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev, rf); return p; }//遍历调度类again: for_each_class(class) { p = class-&gt;pick_next_task(rq, prev, rf); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } /* The idle class should always have a runnable task: */ BUG();} 睡眠和唤醒 睡眠：进程将自己标记为休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择和执行一个其他进程。 唤醒：进程被设置为可执行状态，然后从等待队列中移到可执行红黑树中。 等待队列 等待队列是由等待某些事件发生的进程组成的简单链表。可以通过DECLARE_WAITQUEUE()静态创建，也可以由init_waitqueue_head()动态创建。 内核使用wait_queue_head_t结构来表示一个等待队列，它其实就是一个链表的头节点，但是加入了一个自旋锁来保持一致性（等待队列在中断时可以被随时修改） include/linux/wait.h： 12345struct wait_queue_head { spinlock_t lock; struct list_head head;};typedef struct wait_queue_head wait_queue_head_t; 通过执行下面几个步骤将自己加入一个等待队列： 调用宏DEFINE_WAIT()创建一个等待队列的项（链表的节点） 调用add_wait_queue()把自己加到队列中去。该队列会在进程等待的条件满足时唤醒它，当然唤醒的具体操作需要进程自己定义好（你可以理解为一个回调） 调用prepare_to_wait()方法把自己的状态变更为上面说到的两种休眠状态中的其中一种。 kernel/sched/wait.c: 123456789void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry){ unsigned long flags; wq_entry-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE; spin_lock_irqsave(&amp;wq_head-&gt;lock, flags); __add_wait_queue(wq_head, wq_entry); spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);} 12345//wait.hstatic inline void __add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry){ list_add(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);} 123456789101112voidprepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state){ unsigned long flags; wq_entry-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE; spin_lock_irqsave(&amp;wq_head-&gt;lock, flags); if (list_empty(&amp;wq_entry-&gt;entry)) __add_wait_queue(wq_head, wq_entry); set_current_state(state); spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);} 唤醒 唤醒操作主要通过wake_up()实现，它会唤醒指定等待队列上的所有进程。内部由try_to_wake_up()函数将对应的进程标记为TASK_RUNNING状态，接着调用enqueue_task()将进程加入红黑树中。 抢占和上下文切换 上下文切换 上下文切换是指从一个可执行进程切换到领一个可执行进程，由context_switch()实现。 上下文切换由schedule()函数在切换进程时调用。但是内核必须知道什么时候调用schedule()，如果只靠用户代码显式地调用，代码可能会永远地执行下去。 为此，内核为每个进程设置了一个need_resched标志来表明是否需要重新执行一次调度，当某个进程应该被抢占时，scheduler_tick()会设置这个标志，当一个优先级高的进程进入可执行状态的时候，try_to_wake_up()也会设置这个标志位，内核检查到此标志位就会调用schedule()重新进行调度。 用户抢占 简单来说有以下两种情况会发生用户抢占： 从系统调用返回用户空间 从中断处理程序返回用户空间 内核抢占 在Linux中，只要重新调度是安全的，内核就可以在任何时间抢占正在执行的任务，这个安全是指，只要没有持有锁，就可以进行抢占。 为了支持内核抢占，Linux做出了如下的变动： 为每个进程的thread_info引入了preempt_count计数器，用于记录持有锁的数量，当它为0的时候就意味着这个进程是可以被抢占的。 从中断返回内核空间的时候，会检查need_resched和preempt_count的值，如果need_resched被标记，并且preempt_count为0，就意味着有一个更需要调度的进程需要被调度，而且当前情况是安全的，可以进行抢占，那么此时调度程序就会被调用。 除了响应中断后返回，还有一种情况会发生内核抢占，那就是内核中的进程由于阻塞等原因显式地调用schedule()来进行显式地内核抢占：当然，这个进程显式地调用调度进程，就意味着它明白自己是可以安全地被抢占的，因此我们不用任何额外的逻辑去检查安全性问题。 下面罗列可能的内核抢占情况： 中断处理正在执行，且返回内核空间之前 内核代码再一次具有可抢占性时 内核中的任务显式地调用schedule() 内核中的任务被阻塞 实时调度策略Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR. SCHED_FIFO 这是一种简单的先入先出的调度算法，一旦一个SCHED_FIFO级进程处于可执行状态，就会一直执行。直到它自己受阻塞或显式的释放处理器为止。 SCHED_RR SCHED_RR与SCHED_FIFO大体相同，但SCHED_RR级进程在耗尽事先分配给他的时间后就不再继续执行，SCHED_RR是带有时间片的SCHED_FIFO。 总结进程调度是内核的重要组成部分，Linux操作系统为了寻求调度周期和吞吐量的平衡以及满足各种负载的需求，使用的CFS调度能够尽量满足这些需求。","link":"/37aac71a/"},{"title":"编译原理——LL(1)分析","text":"LL(1)分析法是一种自顶向下的分析方法，从左向右扫描输入串，采用最左推导，每次推导向前看一个符号，确定应该选择的规则。 程序功能 设计目标 给定文法以及输入串，自动构造分析表，输出分析过程。 开发环境 我选择了Java来实现这次的LL(1)分析器，使用IntelliJ IDEA开发。 程序的输入输出 该项目的输入分为两部分： 文法输入 文法通过文件读取的方式读入，文件结构：第一行为使用逗号分隔的非终结符，第二行为使用逗号分隔的终结符，其后是各个产生式，空串使用~表示。 输入串 输入串通过键盘输入，以#结尾。 该项目输出包括当前文法、预测分析表、对当前输入串的分析过程。 主要数据结构 Config.java Config类中定义了几个主要数据内容： 类型名称内容ArrayList&lt;production&gt;productions产生式动态数组ArrayList&lt;String&gt;VT非终结符集ArrayList&lt;String&gt;VN终结符集Stringnullstr空串~ Production.java Production类用来存储产生式，内部主要有两个变量： 12String head;String body[]; 顾名思义，head用于存储产生式左部，body数组用来存储当前head对应的所有右部。 Set.java Set类用来存放FIRST集和FOLLOW集，同样用head存储非终结符，用动态数组body存放First集或者Follow集的内容。 AnalysisTable.java AnalysisTable类用于自动生成分析表。分析表是一个String类型的二维数组，该数组中的[0, 0]位置为空，[0, 1][0, 终结符个数 + 1]存放终结符，[1, 0][非终结符个数 + 1]存放非终结符，其他位置存放产生式或者置空。 AnalyzeStack.java AnalyzeStack类用于分析输入串。 类型名称内容StringinputStr用户输入串Stack&lt;String&gt;stProduction产生式分析栈Stack&lt;String&gt;stInputStr输入串分析栈booleanstop是否停止分析StringcurrentPro当前使用的产生式 LL(1)分析中需要解决的几个问题 文法需要满足的条件 进行LL(1)分析的文法应该满足无二义性、无左递归、无左公因子。 如何构造分析表 构造分析表需要用到当前产生式的FIRST集和FOLLOW集，下面先介绍一下FIRST集和FOLLOW集的构造方法以及具体实现 FIRST集和FOLLOW集 FIRST集合概念：对α∈(VT⋃VN)∗,有FIRST(α)＝{a|α⟹∗a⋅⋅⋅,a∈VT} 特别地，若α⟹∗ε,则ε∈FIRST(α)。 FOLLOW集合概念：对A∈VN，有FOLLOW(A)={a|S⟹∗⋅⋅⋅Aa⋅⋅⋅，a∈VT} 若S⟹∗⋅⋅⋅A，则规定#∈FOLLOW(A) 这里用#作为输入串的结束符。 构造FIRST集的算法 对G[S]，x∈Vn ∪ Vt，计算FIRST(x) ① 若x∈Vt 则FIRST(x)={x} ②若x∈Vn，有x→aα(a∈Vt)或/和x→ε则a或/和ε∈FIRST(x) ③对x→Y1Y2 …….Yk (且Y1 ∈Vn)，反复使用以下直到每一个FIRST(x)不再增大为止： 若Y1∈Vn则把FIRST(Y1)-{ε}元素加入FIRST(x)中 若Y1、Y2、……Yi-1∈Vn (2≤i≤k)且ε ∈FIRST(Yj) (1≤j≤i-1)则把FIRST(Y i )-{ε}元素加入FIRST(x)中 若Y1、Y2、……Yk∈Vn且ε ∈FIRST(Yj)则把ε元素加入FIRST(x)中 我们结合代码以及注释看一下First集的构造过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class FirstSet { static Set getFirst(String str) { Set set = new Set(str);// 如果X∈VT，则FIRST(X)={X} if(Config.VT.contains(str)) { set.addSet(str); return set; }// X∈VN for(Production production: Config.productions) {// 当前str与产生式匹配 if(production.head.equals(str)) { for (int i = 0; i &lt; production.body.length; i++) {// 获取当前str对应第一个产生式的第一个字符 String firstCh = String.valueOf(production.body[i].charAt(0));// 当前字符为终结字符 if(Config.VT.contains(firstCh)) { set.addSet(firstCh); }// 当前字符为空串（~）且该产生式长度为1 else if (firstCh.equals(Config.nullstr) &amp;&amp; production.body[i].length() == 1) { set.addSet(production.body[i]); }// 求该非终结符的first集并加入当前str的first集中 else { set.addSet(getFirstFromN(production.body[i])); } } } } return set; } private static Set getFirstFromN(String str) { boolean[] isEnd = new boolean[str.length()]; Set set = new Set(); for (int i = 0; i &lt; str.length(); i++) { String firstCh = String.valueOf(str.charAt(i));// 如果是终结符，则直接加入first集 if(Config.VT.contains(firstCh)) { set.addSet(firstCh); return set; }// 不是终结符，继续获取该非终结符的first集 Set childSet = getFirst(firstCh);/* 若Y1、Y2、……Yi-1∈Vn(2≤i≤k) 且ε∈FIRST(Y j ) (1≤j≤i-1) 则把FIRST(Yi)-{ε}元素加入FIRST(x)中 */ if (childSet != null) {// 当前非终结符的first集不含空串，则添加到first集中 if(!childSet.contains(Config.nullstr)) { isEnd[i] = false; set.addSet(childSet); return set; }// 含空串，则将该first集中的空串移除 else { isEnd[i] = true; childSet.remove(Config.nullstr); set.addSet(childSet); } } }/* 若Y1、Y2、……Yk∈Vn 且ε∈FIRST(Yj) 则把ε元素加入FIRST(x)中 */ for (boolean anIsEnd : isEnd) { if (anIsEnd) { set.addSet(Config.nullstr); } } return set; }} 构造FOLLOW集的算法 令#∈FOLLOW(S) S为文法开始符号 对A→αBβ，且β≠ε则将 FIRST(β)-{ε}加入FOLLOW(B)中 反复，直至每一个FOLLOW(A)不再增大 对A→ αB或A→ αBβ(且ε∈FIRST(β)) 则FOLLOW(A)中的全部元素加入FOLLOW(B) 具体代码及注释如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.ArrayList;class FollowSet { static Set getFollow(String str) { ArrayList&lt;String&gt; follow = new ArrayList&lt;&gt;(); Set set = new Set(str);// str是终结符 if (Config.VT.contains(str)) { return set; } else { follow.add(str); }// 将#加入FOLLOW(文法开始符号) if (Config.productions.get(0).head.equals(str)) { set.addSet(Config.endSyntax); } for (Production production : Config.productions) { if(production.contains(str)) {// 获取该产生式中包含当前str的产生式 ArrayList&lt;String&gt; list = production.getBody(str); for (String contain : list) { int index = contain.indexOf(str);// 对A-&gt;αB(且ε∈FIRST(β))// 则FOLLOW(A)中的全部元素加入FOLLOW(B) if (index == contain.length() - 1) { if (!follow.contains(production.head)) { set.addSet(getFollow(production.head)); } } else {// 获取当前str的下一个字符 String nextCh = String.valueOf(contain.charAt(index + 1));// 终结符，则直接加入Follow集中 if (Config.VT.contains(nextCh)) { set.addSet(nextCh); }// 非终结符 else {// 获取该字符的First集 Set subSet = FirstSet.getFirst(nextCh); if (subSet != null) { if (subSet.contains(Config.nullstr) &amp;&amp; !follow.contains(subSet.head)) { set.addSet(getFollow(subSet.head)); } subSet.remove(Config.nullstr); set.addSet(subSet); } } } } } } return set; }} 构造分析表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class AnalysisTable { String[][] table = new String[Config.VN.size() + 1][Config.VT.size() + 1]; void generate() {// 将分析表初始化为空 for (int i = 0; i &lt; Config.VN.size() + 1; i++) { for (int j = 0; j &lt; Config.VT.size() + 1; j++) { table[i][j] = &quot;&quot;; } }// 初始化分析表的第一行为终结符，第一列为非终结符 for (int i = 1; i &lt; Config.VT.size() + 1; i++) { table[0][i] = Config.VT.get(i - 1); } for (int i = 1; i &lt; Config.VN.size() + 1; i++) { table[i][0] = Config.VN.get(i - 1); }// 对每一个产生式，分别进行分析 for (Production production : Config.productions) { for (int i = 0; i &lt; production.body.length; i++) { String head = production.head; String pro = production.body[i]; Set tmpFirst = FirstSet.getFirst(head); Set tmpFollow = FollowSet.getFollow(head);// 若该产生式右部第一项为终结符且该产生式不为空串，则直接将对应表格置为该产生式 if (Config.VT.contains(String.valueOf(production.body[i].charAt(0))) &amp;&amp; !production.body[i].equals(Config.nullstr)) { String str = String.valueOf(production.body[i].charAt(0)); ArrayList&lt;Integer&gt; tmp = getPos(head, str); table[tmp.get(0)][tmp.get(1)] = pro; continue; }// 若该产生式为空串，直接将表格对应项置为该产生式 if (!production.body[i].equals(&quot;~&quot;)) { for (String str : tmpFirst.body) { ArrayList&lt;Integer&gt; tmp = getPos(head, str); table[tmp.get(0)][tmp.get(1)] = pro; } }// 当前非终结符的First集含空串 if (tmpFirst.contains(Config.nullstr)) {// 对于任一个b∈FOLLOW(A) b∈Vt或#，将A→ε规则填入M[A, b] pro = &quot;#&quot;; for (String str : tmpFollow.body) { if (str.equals(&quot;#&quot;)) str = &quot;~&quot;; ArrayList&lt;Integer&gt; tmp = getPos(head, str); table[tmp.get(0)][tmp.get(1)] = pro; } } } } }// 获取M[head, VT]的位置 ArrayList&lt;Integer&gt; getPos (String head, String VT) { ArrayList&lt;Integer&gt; pos = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; Config.VN.size() + 1; i++) { if(table[i][0].equals(head)) { pos.add(i); break; } } for (int i = 0; i &lt; Config.VT.size() + 1; i++) { if (table[0][i].equals(VT)) { pos.add(i); break; } } return pos; }} 输入串分析过程 首先，我们把输入串也放到一个栈中，方便输入串与分析栈匹配时的pop操作。分析栈栈底为#，初始化先将起始符号压入分析栈中，同时将输入串压入输入串栈中。 当分析栈栈顶不为#时，分析过程一直进行下去 若分析栈栈顶字符与输入串栈顶字符相同，则对两个栈都执行pop操作，否则用分析表中合适的产生式替换当前分析栈中非终结符。 产生式的选择： 根据当前分析栈栈顶的非终结符和当前输入串最左终结符确定产生式 产生式=分析表[分析栈栈顶的非终结, 输入串最左终结符] 具体代码及注释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class AnalyzeStack { private String inputStr; private Stack&lt;String&gt; stProduction = new Stack&lt;&gt;(); private Stack&lt;String&gt; stInputStr = new Stack&lt;&gt;(); private boolean stop = false; private String currentPro;// 获取输入串，初始化栈 private void init() { Scanner scanner = new Scanner(System.in); if (scanner.hasNext()) { inputStr = scanner.next(); System.out.println(inputStr); } scanner.close(); int index = inputStr.length(); while ( index &gt; 0 ) { stInputStr.push(String.valueOf(inputStr.charAt(index - 1))); index--; } System.out.println(&quot;Stack\\t\\tInput\\t\\tProduction&quot;); stProduction.push(&quot;#&quot;); stProduction.push(Config.productions.get(0).head); outputStack(); } void stack (AnalysisTable analysisTable) { init();// 判断当前分析工作是否完成 while ( !stProduction.peek().equals(&quot;#&quot;) ) { if (stProduction.peek().equals(stInputStr.peek())) { stProduction.pop(); stInputStr.pop(); currentPro = &quot;Pop, Next&quot;; } else { nextProduction(analysisTable); } if (stop) { System.out.println(&quot;error&quot;); break; } outputStack(); }// 当分析栈栈顶与输入串栈顶均为#时，分析成功 if (stProduction.peek().equals(stInputStr.peek())) System.out.println(&quot;Success!&quot;); } private void nextProduction(AnalysisTable analysisTable) { analysisTable.generate();// ch为当前输入串栈栈顶 String ch = stInputStr.peek();// head为当前分析栈栈顶 String head = stProduction.peek();// 获取M[head, ch]在表中对应的位置 ArrayList&lt;Integer&gt; pos = analysisTable.getPos(head,ch);// 将当前分析栈栈顶的非终结符用合适产生式替换 if (pos.size() == 2) { stProduction.pop(); String production = analysisTable.table[pos.get(0)][pos.get(1)]; currentPro = head + &quot;-&gt;&quot; + production; if (!production.equals(&quot;#&quot;)) { int index = production.length(); while ( index &gt; 0 ) { stProduction.push(String.valueOf(production.charAt(index - 1))); index--; } } } else if (FirstSet.getFirst(head).contains(Config.nullstr)) { stProduction.pop(); currentPro = head + &quot;-&gt;~&quot;; } else { stop = true; } } private void outputStack() { for (String aStProduction : stProduction) { System.out.print(aStProduction); } if (stProduction.size() &lt; 4) System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t\\t&quot;); for (int i = stInputStr.size(); i &gt; 0; i-- ) { System.out.print(stInputStr.get(i - 1)); } if (stInputStr.size() &lt; 4) System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t\\t&quot; + currentPro); System.out.println(); }} 程序结构 项目结构 各文件结构以及函数 LL1.java main：入口函数 readFromFIle：从文件中读取文法 addVTandVN：将存放在String类型VT和VN数组中的非终结符和终结符添加到Config.java中的非终结符和终结符动态数组中 Production.java Production：构造函数，初始化产生式左部和右部 getBody：得到当前产生式右部的动态数组 contains：返回当前产生式右部是否包含传入参数 outputPro：输出当前产生式 Set.java 构造函数用于初始化该集合对应的非终结符并且初始化动态数组。 addSet(String)：向集合中添加String类型未存在的元素 addSet(Set)：向集合中添加Set类型元素，即添加新集合 getSet：返回该集合的动态数组 remove：删除集合中某元素 outputSet：输出当前集合 contains：判断当前集合中是否存在该元素 FirstSet.java getFirst：生成First集的入口函数 getFirstFromN：当遇到非终结符时，求该非终结符的First集 FollowSet.java getFollow：生成Follow集 AnalysisTable.java generate：生成分析表 getPos：返回当前产生式应当放置的位置 AnalyzeStack.java init：从键盘获取用户输入串，并且初始化输入串栈和分析栈 stack：主要的分析函数 nextProduction：调用下一个合适的产生式 outputStack：输出当前栈内容 程序测试 测试用例 测试文件内容为： 123456789E,e,T,t,F,A,Mi,+,-,*,/,(,),~E-&gt;Te e-&gt;ATe|~T-&gt;Ftt-&gt;MFt|~F-&gt;(E)|iA-&gt;+|-M-&gt;*|/ 运行结果 输入串为i*(i+i)时： 输入串为i*(i+i时（错误情况）： 实验总结LL(1)的分析过程并不是复杂，这个实验的主要复杂点在于自动构造分析表，构造的算法不是特别的难，但是很繁杂，因此耗费了我一些时间。通过这次的实验，我最大的体会是我写代码的能力还是需要提高，要通过多的练习提升自己将算法转化为实际代码的能力。 项目地址：https://github.com/Panda-0129/LL1","link":"/b139564e/"},{"title":"编译原理——SLR语法分析","text":"SLR分析实验的难点在于构造SLR的分析表，构造分析表首先要求出拓广文法对应的项目集规范族，再根据项目集规范族构造分析表。虽然看上去并不是很复杂，但在实现的过程中遇到了很多问题，由于考虑问题不够全面，刚开始写的代码中有很多的bug，在调试分析的过程中花费了我很多的时间。 程序功能输入通过读取文件方式获取拓广文法G’，通过键盘输入获取以#结尾的待分析串。 输出输出当前文法，以及该文法的项目集规范族、文法中所有非终结符的FOLLOW集，对当前分析串的分析过程。 LR分析LR分析法是一种自底向上的语法分析技术，它适用于上下文无关文法的语法分析。L指的是从左向右扫描输入字符串，R指的是构造最右推导的逆过程，k指的是在决定语法分析动作时需要向前看的符号个数。 LR分析的优点 LR语法分析器几乎能够识别所有能用上下文无关文法描述的程序设计语言结构。 LR分析法是已知的最一般的无回溯移动归约语法分析法，而且可以和其他移动归约分析法一样被有效地实现。 LR分析法分析的文法类是预测分析法能分析的文法类的真超集。 在自左向右扫描输入符号串时，LR语法分析器能及时发现语法错误。 LR分析算法LR语法分析器由输入、输出、栈、驱动程序以及包含动作和转移两部分的语法分析表组成。对于所有的LR语法分析器，驱动程序都是相同的，分析程序每次从输入缓冲区读入一个符号，并使用栈来保存形如S0X1S1X2S2…XmSm的串，其中Sm在栈顶，Xi是文法符号，Si是状态符号，在SLR分析表中，就是第一列的stateNum。栈顶的状态符号和当前的输入符号用来检索语法分析表，以决定移动归约分析的动作。 语法分析表由动作函数action和转移函数goto两部分组成。 LR分析算法可以用下面的过程表示： 输入：文法G的LR语法分析表和输入串w 输出：如果w属于L(G)，则输出w的自底向上分析，否则报错。 方法：首先把初始状态0放在语法分析器栈顶，把w#放在输入缓冲区，然后执行如下程序： 123456789101112131415161718令ip指向w#的第一个符号：repeat forever begin令s是栈顶状态，a是ip所指向的符号；if action[s, a] = “移动状态s进栈” then begin把a和S对应的stateNum依次压入栈顶；ip++；endelse if action[s, a] = “按文法产生式A-&gt;ß归约” then begin从栈顶弹出2*|ß长度|个符号；令s对应的stateNum为现在的栈顶状态；把A和goto[stateNum, A]依次压入栈；输出产生式A-&gt;ß;endend if action[s, a] = “接收” thenreturn；else error()end 接下来我们结合具体的代码以及注释看一下分析过程的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041static void analyze () {// init()主要工作是从键盘获取输入串，初始化分析栈以及输入串栈 init(); while ( true ) { String s = stAnalysis.peek(); String a = stInputStr.peek();// 获取分析表中[s, a]项内容 String content = AnalysisTable.getContent(Integer.valueOf(s), a); /*如果content内容是接收，则说明分析成功 如果content为空，则说明分析过程出错*/ if (content.equals(Config.accept)) { outputStack(content); System.out.println(&quot;success&quot;); return; } else if (!content.equals(&quot;&quot;)) {// 获取S或者r的stateNum int stateNum = Integer.parseInt (content.substring(1, content.length()));// 移动进栈状态时，根据算法中的步骤执行 if (content.charAt(0) == 'S') { outputStack(content); stAnalysis.push(a); stAnalysis.push(String.valueOf(stateNum)); stInputStr.pop(); } // 按文法产生式归约的情况 else if (content.charAt(0) == 'r') { outputStack(content); for (int i = 0; i &lt; 2 * Config.productions.get(stateNum).body.length(); i++) { stAnalysis.pop(); } int tmp = Integer.valueOf(stAnalysis.peek()); stAnalysis.push(Config.productions.get(stateNum).head); stAnalysis.push(AnalysisTable.getContent(tmp, Config.productions.get(stateNum).head)); } } else { System.out.println(&quot;error&quot;); return; } }} 构造分析表LR文法如果我们能够为G构造出LR语法分析表，则称G为LR文法。直观得讲，为了使一个文法是LR文法，只要保证在句柄出现在栈顶时，自左向右扫描的移动归约分析器能够及时识别它。 文法G的LR(0)项目文法G的LR(0)项目是在G的产生式右部某处加点的产生式。 例如：产生式A-&gt;XYZ可以生产如下四个项目： ​ A-&gt;·XYZ ​ A-&gt;X·YZ ​ A-&gt;XY·Z ​ A-&gt;XYZ· 产生式A-&gt;ε只生成一个项目A-&gt;·。项目表示在语法分析过程中的某一时刻，我们已经看见了一个产生式所能推出的字符串的多大部分。例如，上面的第一个项目表示我们希望下一步从输入中看见由XYZ推出的字符串，第二个项目表示我们刚从输入中看见了由X推出的字符串，下面希望看见由YZ推出的字符串。 下面结合具体代码来看一下项目类的结构： 123456789101112131415public class Item extends Production { int dotPos; Item(String head, String body, int pos) { super(head, body); this.dotPos = pos; } @Override public String toString () { String front = body.substring(0, dotPos); String behind = body.substring(dotPos, body.length()); return head + &quot;-&gt;&quot; + front + &quot;·&quot; + behind; }} Item类继承自Production类，Production是产生式类，主要属性有产生式的左部head以及右部body，Item类中增加了一个dotPos属性，表示点在产生式右部的位置，并且重写了toString方法，调用toString方法时返回带·的产生式。 再来看一下项目集类的结构： 123456789101112131415161718192021222324252627282930class ItemSet { ArrayList&lt;Item&gt; items = new ArrayList&lt;&gt;(); Item get(int i) { return items.get(i); } void add(Item item) { items.add(item); } void add(Production production) { Item item = new Item(production.head, production.body, 0); if (contains(item)) { return; } items.add(item); } private boolean contains(Item item) { for (Item tmpItem : items) { if (tmpItem.head.equals(item.head) &amp;&amp; tmpItem.body.equals(item.body) &amp;&amp; tmpItem.dotPos == item.dotPos) return true; } return false; }} 项目集是类型为Item的动态数组。 SLR方法的思想SLR方法的主要思想：首先从文法构造出识别活前缀的确定有穷自动机。我们把项目划分成一组集合，这些集合对应DFA的状态，而项目可以看成是识别活前缀的NFA的状态。我已经提到过，项目集规范族是构造语法分析表的基础，而为了构造项目集规范族，我们需要定义拓广文法，并且引入闭包运算（closure）和转移函数（go）。 拓广文法如果文法G的开始符号是S，那么G的拓广文法G’是在G的基础上增加一个新的开始符号s和产生式s-&gt;S。新产生式的目的是来指示语法分析器什么时候应该停止分析并接受输入，即当语法分析器执行归约s-&gt;S时，分析成功。 闭包运算与转移函数如果I是文法G的项目集，那么closure(I)是从I出发由下面两条规则构造的项目集： 初始时，把I的每个项目都加入到closure(I)中； 如果A-&gt;α·Bβ在closure(I)中，且存在产生式B-&gt;γ，若B-&gt;·γ不在closure(I)中，则将其加入closure(I)。反复运用该规则，知道没有更多的项目可加入closure(I)为止。 Go(I, X)函数定义为所有项目集[A-&gt;αX·β]的闭包。如果I是对某个活前缀γ的有效项目集，那么Go(I, X)是对活前缀γX有效的项目集。 项目集的构造先求第一条产生式(s-&gt;S)的闭包，再从这个闭包产生的项目集开始，对每个项目集I和每个文法符号X都执行Go(I, X)运算，将结果加入到项目集中，直到没有更多的项目可以加入到项目集为止。 构造项目集规范族的过程写在ItemSets类中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175import java.util.ArrayList;class ItemSets {// 获取所有形如Vn-&gt;...的产生式 private static ArrayList&lt;Production&gt; getProductionByVn(String Vn) { ArrayList&lt;Production&gt; productions = new ArrayList&lt;&gt;(); for (Production production : Config.productions) { if (production.head.equals(Vn)) productions.add(production); } return productions; } // 构造I0 static void generateItemSets () { ItemSet itemSet = new ItemSet(); itemSet.add(Config.productions.get(0));// *后跟非终结符 if (Config.VN.contains(itemSet.get(0).body.substring(0, 1))) { ArrayList&lt;Production&gt; productions = getProductionByVn(itemSet.get(0).body); for (Production production : productions) { itemSet.add(production); generateItemSetsByProduction(itemSet, production); } } Config.itemSets.add(itemSet); } /*若当前产生式右部的首字符为非终结符，即对应·VN的情况， 则将通过当前产生式右部作为head获取到的产生式添加到该项目集中。*/ private static void generateItemSetsByProduction (ItemSet itemSet, Production production) { String ch = String.valueOf(production.body.charAt(0)); if (Config.VN.contains(ch)) { ArrayList&lt;Production&gt; productions = getProductionByVn(ch); for (Production tmpProduction : productions) { itemSet.add(tmpProduction); } } } static ItemSet Go (ItemSet itemSet, String X) {// 保存Go(I, X)的结果 ItemSet result = new ItemSet();// tmpVN用来记录当前VN是否已经在这次运算中添加 ArrayList&lt;String&gt; tmpVN = new ArrayList&lt;&gt;(); for (Item item : itemSet.items) { Item tmp;// 当前项目符合A-&gt;α·Bβ形式 if (item.dotPos != item.body.length() &amp;&amp; String.valueOf(item.body.charAt(item.dotPos)).equals(X)) {// 先将A-&gt;αB·β添加到项目集中 tmp = new Item(item.head, item.body, item.dotPos + 1); result.add(tmp); if (tmp.dotPos != tmp.body.length()) { if (Config.VN.contains( String.valueOf( tmp.body.charAt(tmp.dotPos))) &amp;&amp; !tmpVN.contains(String.valueOf( tmp.body.charAt(tmp.dotPos)))) { ArrayList&lt;Production&gt; productions = getProductionByVn( String.valueOf(tmp.body.charAt(tmp.dotPos))); for (Production production : productions) { result.add(production); generateItemSetsByProduction(result, production); tmpVN.add(production.head); } } } } } ItemSet moreVn = new ItemSet(); for (Item item : result.items) { if (item.dotPos != item.body.length() &amp;&amp; Config.VN.contains(String.valueOf(item.body.charAt(item.dotPos)))) { ArrayList&lt;Production&gt; productions = getProductionByVn(String.valueOf(item.body.charAt(item.dotPos))); for (Production production : productions) { moreVn.add(production); generateItemSetsByProduction(moreVn, production); tmpVN.add(production.head); } } } for (Item item : moreVn.items) { if (!isContainItem(item, result)) result.add(item); } return result; } // index为项目集下标 static void buildItemSet (int index) { ItemSet beginItemSet = Config.itemSets.get(index); buildItemSetElement(beginItemSet);// 对每个项目集进行遍历 if (index &lt; Config.itemSets.size() - 1) { buildItemSet(index + 1); } }// 对当前项目集进行Go运算 private static void buildItemSetElement (ItemSet itemSet) { for (String vn : Config.VN) { ItemSet result = Go(itemSet, vn); if (result.items.size() &gt; 0 &amp;&amp; contains(result)) Config.itemSets.add(result); } for (String vt : Config.VT) { ItemSet result = Go(itemSet, vt); if (result.items.size() &gt; 0 &amp;&amp; contains(result)) Config.itemSets.add(result); } }// 当前项目集规范族中是否存在该项目集 private static boolean contains (ItemSet itemSet) { boolean flag = true; for (ItemSet itemSet1 : Config.itemSets) { if (itemSet.items.size() != itemSet1.items.size()) { flag = false; } else { boolean tmp = true; for (int i = 0; i &lt; Math.min(itemSet1.items.size(), itemSet.items.size()); i++) { if (!(itemSet.items.get(i).head.equals( itemSet1.items.get(i).head) &amp;&amp; itemSet.items.get(i).body.equals( itemSet1.items.get(i).body) &amp;&amp; itemSet.items.get(i).dotPos == itemSet1.items.get(i).dotPos)) { tmp = false; } } if (tmp) { flag = true; break; } else { flag = false; } } } return !flag; } static void outputItemSets () { System.out.println(&quot;项目集规范族：&quot;); int num = 0; for (ItemSet itemSet : Config.itemSets) { System.out.println(&quot;I&quot; + num + &quot;: &quot;); num++; for (Item item : itemSet.items) { System.out.println(item.toString()); } } }// 当前项目集中是否存在该项目 private static boolean isContainItem(Item item, ItemSet itemSet) { for (Item tmp : itemSet.items) { if (item.head.equals(tmp.head) &amp;&amp; item.body.equals(tmp.body) &amp;&amp; item.dotPos == tmp.dotPos) return true; } return false; }} 构造SLR语法分析表SLR是LR分析表中功能最弱但最易实现的，构造分析表的先决条件包括：拓广文法G’的项目集规范族C，每个非终结符A的Follow集。 SLR语法分析表的构造： 输入：拓广文法G’ 输出：G’的SLR语法分析表函数action和goto 方法： 构造C 从Ii构造状态i，分析动作如下： 如果[A-&gt;α·aβ]在Ii中，并且Go(Ii, a) = Ij，则置action[i, a]为“移动j进栈”（Sj），这里的a必须是终结符。 如果[A-&gt;α·]在Ii中，则对FOLLOW(A)中的所有a，置action[i, a]为“归约A-&gt;α”。这里的A不能是s（起始符号）。 如果[s-&gt;S·]在Ii中，则置action[i, #]为“接收”。 如果上述规则产生的动作有冲突，那么G就不是SLR(1)文法。在这种情况下是构造不出G的语法分析器的。 对所有的非终结符A，使用下面的规则构造状态i的goto函数： 如果Go(Ii, A) = Ij，则goto[i, A] = j。 语法分析器的初始状态是从包含[s-&gt;·S]的项目集构造出的状态。 我定义了一个AnalysisItem类来存放每一个分析项目： 1234567891011class AnalysisItem { int stateNum; String actionOrGoto; String content; AnalysisItem(int stateNum, String actionOrGoto, String content) { this.stateNum = stateNum; this.actionOrGoto = actionOrGoto; this.content = content; }} stateNum保存当前项目的状态，actionOrGoto是当前项目对应的文法符号，content是当前项目的内容。 构造分析表的具体代码，其他功能函数具体实现可以查阅项目中AnalysisTable文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static void generateTable () {// 遍历项目集规范族中的每个项目 for (ItemSet itemSet : Config.itemSets) { for (Item item : itemSet.items) {// 获取该项目集在项目集规范族中的位置，即Ii的下标i int indexOfI = Config.itemSets.indexOf(itemSet); AnalysisItem analysisItem;// 该项目是否为A-&gt;α·形式 if (item.dotPos != item.body.length()) {// 获取Ij = Go(I, X) ItemSet tmpItemSet = ItemSets.Go(itemSet, String.valueOf(item.body.charAt(item.dotPos)));// 获取下标j int indexOfJ = indexOf(tmpItemSet);// 若满足A-&gt;α·aß，且a为终结符，则置action[i, a]为Sj if (Config.VT.contains(String.valueOf(item.body.charAt(item.dotPos)))) { analysisItem = new AnalysisItem(indexOfI, String.valueOf(item.body.charAt(item.dotPos)), &quot;S&quot; + Integer.toString(indexOfJ)); if (isContainAnalysisItem(analysisItem)) { Config.analysisTable.add(analysisItem); } } } else {// 满足A-&gt;α·，且α不为起始符号，则对FOLLOW(A)中所有的a，// 置action[i, a]为rj，j为A-&gt;α在文法中的位置 if (!item.head.equals(Config.productions.get(0).head) &amp;&amp; Config.VN.contains(item.head)) { Set set = FollowSet.getFollow(item.head); int indexJ = indexOfProduction(item); for (String follow : set.body) { analysisItem = new AnalysisItem(indexOfI, follow, &quot;r&quot; + Integer.toString(indexJ)); if (isContainAnalysisItem(analysisItem)) { Config.analysisTable.add(analysisItem); } } }// 对s-&gt;S·，置action[i, #]为接受 if (item.head.equals(Config.productions.get(0).head) &amp;&amp; item.body.equals(Config.productions.get(0).body) &amp;&amp; item.dotPos == 1) { analysisItem = new AnalysisItem(indexOfI, Config.endSyntax, Config.accept); if (isContainAnalysisItem(analysisItem)) { Config.analysisTable.add(analysisItem); } } }// 对所有的非终结符，使用下面的规则构造状态i的goto函数：// 如果Go(Ii, A) = Ij，则goto[i, A] = j。 for (String vn : Config.VN) { ItemSet tmpItemSet = ItemSets.Go(itemSet, vn); if (tmpItemSet.items.size() &gt; 0) { int indexJ = indexOf(tmpItemSet); analysisItem = new AnalysisItem(indexOfI, vn, Integer.toString(indexJ)); if (isContainAnalysisItem(analysisItem)) { Config.analysisTable.add(analysisItem); } } } } }} 以上就是构造分析表的所有算法，我结合部分代码以及注释进行了解释，完整的项目文件请点击。 程序测试测试用例： 文法 12345678910111213a,A,V,E,T,F=,+,-,*,/,(,),ia-&gt;AA-&gt;V=EE-&gt;E+TE-&gt;E-TE-&gt;TT-&gt;T*FT-&gt;T/FT-&gt;FF-&gt;(E)F-&gt;iV-&gt;i 输入串 i=i+i*(i-i) 运行结果运行结果以文件形式保存，分别为项目集规范族itemSets.txt，分析表analyzeTable.txt以及运行结果result.txt。","link":"/cd8c0c8/"},{"title":"LeetCode 刷题","text":"在JackZhao98项目基础上实现的自动获取LeetCode历史ac retriever.py: 获取所有ac，存入文件夹中 generate_readme.py: 能够自动生成readme.md # Title Difficulty runtime memory 1 Two Sum Easy 4756 ms 13.7 MB 2 Add Two Numbers Medium 80 ms 14.1 MB 3 Longest Substring Without Repeating Characters Medium 40 ms 12.1 MB 4 Median of Two Sorted Arrays Hard 156 ms 14.6 MB 5 Longest Palindromic Substring Medium 1036 ms 13.7 MB 10 Regular Expression Matching Hard 48 ms 14.2 MB 11 Container With Most Water Medium 128 ms 14.4 MB 14 Longest Common Prefix Easy 32 ms 13.9 MB 15 3Sum Medium 1300 ms 17.5 MB 17 Letter Combinations of a Phone Number Medium 24 ms 12.7 MB 18 4Sum Medium 1496 ms 14 MB 19 Remove Nth Node From End of List Medium 32 ms 12.8 MB 32 Longest Valid Parentheses Hard 36 ms 14.2 MB 34 Find First and Last Position of Element in Sorted Array Medium 104 ms 15.1 MB 36 Valid Sudoku Medium 108 ms 13.9 MB 39 Combination Sum Medium 52 ms 14 MB 40 Combination Sum II Medium 40 ms 14.2 MB 44 Wildcard Matching Hard 812 ms 22.7 MB 46 Permutations Medium 48 ms 14 MB 47 Permutations II Medium 48 ms 14.4 MB 51 N-Queens Hard 160 ms 14.5 MB 52 N-Queens II Hard 152 ms 14.2 MB 53 Maximum Subarray Easy 96 ms 12.4 MB 62 Unique Paths Medium 44 ms 13.7 MB 63 Unique Paths II Medium 56 ms 13.8 MB 64 Minimum Path Sum Medium 184 ms 13.3 MB 69 Sqrt(x) Easy 44 ms 11.8 MB 70 Climbing Stairs Easy 20 ms 11.9 MB 75 Sort Colors Medium 40 ms 12 MB 76 Minimum Window Substring Hard 104 ms 14.6 MB 77 Combinations Medium 460 ms 15.7 MB 78 Subsets Medium 36 ms 14.2 MB 79 Word Search Medium 288 ms 15.4 MB 88 Merge Sorted Array Easy 40 ms 13.1 MB 90 Subsets II Medium 40 ms 14.3 MB 93 Restore IP Addresses Medium 332 ms 14.1 MB 94 Binary Tree Inorder Traversal Medium 32 ms 13.9 MB 97 Interleaving String Hard 40 ms 14.3 MB 106 Construct Binary Tree from Inorder and Postorder Traversal Medium 364 ms 18.8 MB 111 Minimum Depth of Binary Tree Easy 92 ms 15 MB 115 Distinct Subsequences Hard 44 ms 14.3 MB 120 Triangle Medium 44 ms 12.9 MB 121 Best Time to Buy and Sell Stock Easy 92 ms 12.8 MB 122 Best Time to Buy and Sell Stock II Easy 92 ms 12.7 MB 123 Best Time to Buy and Sell Stock III Hard 3440 ms 64.3 MB 127 Word Ladder Hard 536 ms 14.8 MB 131 Palindrome Partitioning Medium 72 ms 14.5 MB 139 Word Break Medium 40 ms 12.8 MB 140 Word Break II Hard 120 ms 12.6 MB 141 Linked List Cycle Easy 64 ms 18.4 MB 144 Binary Tree Preorder Traversal Medium 40 ms 13.9 MB 152 Maximum Product Subarray Medium 56 ms 14 MB 153 Find Minimum in Rotated Sorted Array Medium 44 ms 11.9 MB 167 Two Sum II - Input array is sorted Easy 40 ms 13.6 MB 174 Dungeon Game Hard 72 ms 15 MB 179 Largest Number Medium 44 ms 13.9 MB 188 Best Time to Buy and Sell Stock IV Hard 220 ms 25.3 MB 198 House Robber Medium 24 ms 12 MB 205 Isomorphic Strings Easy 44 ms 13.9 MB 208 Implement Trie (Prefix Tree) Medium 168 ms 31.3 MB 212 Word Search II Hard 380 ms 32.4 MB 213 House Robber II Medium 24 ms 11.7 MB 215 Kth Largest Element in an Array Medium 116 ms 12.3 MB 216 Combination Sum III Medium 32 ms 14.1 MB 221 Maximal Square Medium 212 ms 13.8 MB 234 Palindrome Linked List Easy 64 ms 31.3 MB 241 Different Ways to Add Parentheses Medium 56 ms 14.2 MB 242 Valid Anagram Easy 40 ms 12.5 MB 264 Ugly Number II Medium 152 ms 12.8 MB 278 First Bad Version Easy 20 ms 11.7 MB 279 Perfect Squares Medium 6780 ms 12.7 MB 282 Expression Add Operators Hard 1012 ms 14.6 MB 300 Longest Increasing Subsequence Medium 1204 ms 12.7 MB 309 Best Time to Buy and Sell Stock with Cooldown Medium 36 ms 12.9 MB 312 Burst Balloons Hard 336 ms 14.7 MB 322 Coin Change Medium 1120 ms 12.1 MB 337 House Robber III Medium 56 ms 15.9 MB 343 Integer Break Medium 32 ms 12.6 MB 345 Reverse Vowels of a String Easy 76 ms 14.2 MB 347 Top K Frequent Elements Medium 284 ms 15.2 MB 350 Intersection of Two Arrays II Easy 32 ms 14 MB 367 Valid Perfect Square Easy 28 ms 13.9 MB 368 Largest Divisible Subset Medium 432 ms 12.8 MB 376 Wiggle Subsequence Medium 40 ms 13.8 MB 377 Combination Sum IV Medium 48 ms 12.9 MB 387 First Unique Character in a String Easy 40 ms 12 MB 392 Is Subsequence Easy 252 ms 17.4 MB 395 Longest Substring with At Least K Repeating Characters Medium 28 ms 12.3 MB 406 Queue Reconstruction by Height Medium 180 ms 12.2 MB 412 Fizz Buzz Easy 40 ms 12.6 MB 416 Partition Equal Subset Sum Medium 744 ms 12.7 MB 435 Non-overlapping Intervals Medium 72 ms 17.6 MB 438 Find All Anagrams in a String Medium 120 ms 14.8 MB 445 Add Two Numbers II Medium 84 ms 14 MB 448 Find All Numbers Disappeared in an Array Easy 13043 ms 44 MB 451 Sort Characters By Frequency Medium 68 ms 15.8 MB 452 Minimum Number of Arrows to Burst Balloons Medium 1064 ms 17.5 MB 454 4Sum II Medium 296 ms 34.2 MB 455 Assign Cookies Easy 336 ms 13.4 MB 461 Hamming Distance Easy 8 ms 25.9 MB 494 Target Sum Medium 928 ms 14.3 MB 513 Find Bottom Left Tree Value Medium 44 ms 17.2 MB 518 Coin Change 2 Medium 272 ms 13.9 MB 524 Longest Word in Dictionary through Deleting Medium 732 ms 16.9 MB 525 Contiguous Array Medium 808 ms 16.8 MB 540 Single Element in a Sorted Array Medium 72 ms 12.8 MB 543 Diameter of Binary Tree Easy 4 ms 29.2 MB 565 Array Nesting Medium 144 ms 15.8 MB 567 Permutation in String Medium 76 ms 13.7 MB 581 Shortest Unsorted Continuous Subarray Medium 22 ms 29.3 MB 583 Delete Operation for Two Strings Medium 344 ms 17.6 MB 599 Minimum Index Sum of Two Lists Easy 112 ms 12.2 MB 605 Can Place Flowers Easy 328 ms 12.4 MB 617 Merge Two Binary Trees Easy 6 ms 30.8 MB 633 Sum of Square Numbers Medium 124 ms 13.2 MB 648 Replace Words Medium 288 ms 21.2 MB 664 Strange Printer Hard 656 ms 14.3 MB 665 Non-decreasing Array Easy 396 ms 12.4 MB 670 Maximum Swap Medium 16 ms 11.7 MB 680 Valid Palindrome II Easy 188 ms 13.4 MB 687 Longest Univalue Path Medium 412 ms 18.8 MB 695 Max Area of Island Medium 116 ms 14.1 MB 712 Minimum ASCII Delete Sum for Two Strings Medium 1108 ms 18.4 MB 714 Best Time to Buy and Sell Stock with Transaction Fee Medium 776 ms 17.6 MB 718 Maximum Length of Repeated Subarray Medium 3496 ms 39.9 MB 724 Find Pivot Index Easy 124 ms 12.5 MB 739 Daily Temperatures Medium 436 ms 15.1 MB 745 Find Smallest Letter Greater Than Target Easy 220 ms 13.5 MB 747 Min Cost Climbing Stairs Easy 88 ms 13.9 MB 753 Open the Lock Medium 2928 ms 14.9 MB 768 Partition Labels Medium 40 ms 12 MB 777 Toeplitz Matrix Easy 104 ms 13.7 MB 782 Jewels and Stones Easy 36 ms 6.5 MB 792 Binary Search Easy 332 ms 15.1 MB 800 Letter Case Permutation Medium 52 ms 14.2 MB 811 Number of Subarrays with Bounded Maximum Medium 404 ms 15.2 MB 813 All Paths From Source to Target Medium 84 ms 13 MB 853 Most Profit Assigning Work Medium 340 ms 14.7 MB 872 Split Array into Fibonacci Sequence Medium 32 ms 14.1 MB 878 Shifting Letters Medium 168 ms 14.5 MB 891 Score After Flipping Matrix Medium 48 ms 14 MB 923 Super Egg Drop Hard 2436 ms 33.4 MB 928 Surface Area of 3D Shapes Easy 64 ms 11.9 MB 951 Partition Array into Disjoint Intervals Medium 172 ms 15.3 MB 967 Minimum Falling Path Sum Medium 108 ms 14.6 MB 971 Shortest Bridge Medium 428 ms 17.1 MB 1013 Fibonacci Number Easy 28 ms 14 MB 1081 Video Stitching Medium 76 ms 14 MB 1111 Minimum Score Triangulation of Polygon Medium 164 ms 14.5 MB 1236 N-th Tribonacci Number Easy 28 ms 14.2 MB 1250 Longest Common Subsequence Medium 432 ms 22.5 MB 1290 Make Array Strictly Increasing Hard 756 ms 14.5 MB 1322 Minimum Moves to Reach Target with Rotations Hard 9 ms 39.2 MB 1330 Longest Arithmetic Subsequence of Given Difference Medium 520 ms 27.5 MB","link":"/de20ad77/"}],"tags":[{"name":"Graphivz","slug":"Graphivz","link":"/tags/Graphivz/"},{"name":"dot","slug":"dot","link":"/tags/dot/"},{"name":"绘图","slug":"绘图","link":"/tags/%E7%BB%98%E5%9B%BE/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"进程控制","slug":"进程控制","link":"/tags/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"categories":[{"name":"搭建过程","slug":"搭建过程","link":"/categories/%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"name":"Graphviz绘图","slug":"Graphviz绘图","link":"/categories/Graphviz%E7%BB%98%E5%9B%BE/"},{"name":"编译原理","slug":"编译原理","link":"/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"mac","slug":"mac","link":"/categories/mac/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","link":"/categories/Dynamic-Programming/"},{"name":"Backtracking","slug":"Backtracking","link":"/categories/Backtracking/"},{"name":"Dynamic Programing","slug":"Dynamic-Programing","link":"/categories/Dynamic-Programing/"},{"name":"Math","slug":"Math","link":"/categories/Math/"},{"name":"Heap","slug":"Heap","link":"/categories/Heap/"},{"name":"Breadth-first Search","slug":"Breadth-first-Search","link":"/categories/Breadth-first-Search/"},{"name":"Array","slug":"Array","link":"/categories/Array/"},{"name":"String","slug":"String","link":"/categories/String/"},{"name":"Linked List","slug":"Linked-List","link":"/categories/Linked-List/"},{"name":"Hash Table","slug":"Hash-Table","link":"/categories/Hash-Table/"},{"name":"Two Pointers","slug":"Two-Pointers","link":"/categories/Two-Pointers/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"日常学习","slug":"日常学习","link":"/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}]}